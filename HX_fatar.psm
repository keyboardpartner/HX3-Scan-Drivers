                           ;
                           ; ##############################################################################
                           ;
                           ;      #######    #    #######    #    ######
                           ;      #         # #      #      # #   #     #
                           ;      #        #   #     #     #   #  #     #
                           ;      #####   #     #    #    #     # ######
                           ;      #       #######    #    ####### #   #
                           ;      #       #     #    #    #     # #    #
                           ;      #       #     #    #    #     # #     #
                           ;
                           ; ##############################################################################
                           ; ############ KCPSM6 PicoBlaze Keyboard Scanner by cm 10/2010 #################
                           ; #################### for 12 BIT ADDRESS ROM (4096 Words) #####################
                           ; ##############################################################################
                           ;
                           ; https://www.amd.com/en/products/adaptive-socs-and-fpgas/intellectual-property/picoblaze.html
                           ; https://www1.hs-bremerhaven.de/kmueller/VHDL/PB_Instr_Ref.pdf
                           ;
                           ; 10.12.2025 #49 Support für neues FPGA mit separatem SAM5504-MIDI-FIFO, MIDI GETBYTE gestrafft
                           ; 11.07.2025 #47 Neue Organisation der Tastenabfrage mit vertauschter Spalte/Reihe (4017/4024-Zähler), deutlich schneller
                           ; 23.07.2024 #46 Bugfix: MIDI SEND ENABLES waren nicht implementiert, siehe "local_states_out"
                           ; 13.06.2024 #44 Differenzierter Key Click, etwas schwächer; #45 einstellbar on/off
                           ; 29.06.2022 #42 MIDI IN/GenTranspose jetzt für alle, KeyTranspose (Offset) nur MIDI OUT
                           ; 11.01.2022 #41 Extrem verbessertes Timing, 500µs Scan-Loop, einfacheres RAM-Handling
                           ; 31.12.2021 #40 Key Reverse State beim Verlassen der Endstellung, sendet früher, Noise etwas verringert
                           ; 18.10.2021 #39 Octave Shift für Upper und Lower in Manual Scan
                           ; 30.07.2021 #37 Sendet page_init bei Split-Änderungen, SplitMode 5 (AddPedalToLower)
                           ; 18.05.2021 #36 Andere Noise-Berechnung
                           ; 12.01.2021 #33 Bug in ResetDynTimers behoben
                           ; 12.01.2021 #31 Dynamik-Ermittlung über variables Timer-Dekrement (1/t)
                           ; 09.01.2021 #30 Scan-Dynamik jetzt per Statemachine
                           ; 03.09.2020 #28 Keine Übersetzung Sostenuto mehr
                           ; 22.02.2020 #25 Auch Kanal +3 an AVR für Touchpad
                           ; 20.11.2019 #23 MIDI-Dispatcher verbessert, wird öfter ausgeführt
                           ; 10.11.2019 #20 Local Enables auf SPI $2E
                           ; 21.02.2018 #19 Kleine Verzögerung vor Auslesen der Tastenkontakte wg. Emils Geisternoten
                           ; 13.02.2018 #18 Bug in Key Transpose behoben
                           ; 22.11.2018 #17 Split-Handling jetzt nur noch in Tastatur-Scan
                           ; 12.09.2018 #15 Bug in Midi-Kanalwahl behoben
                           ; 14.08.2018 #14 Bug in local_states_off (Dyn. 1 gesendet) behoben
                           ; 09.08.2018 #12 Sostenuto-Controller 42 geändert auf 45, HOLD2-Pedal wg. NI B4-PERC Konflikt
                           ; 24.04.2018 #11 Bugfixes für Fatar
                           ; 20.10.2017 #10 Zusätzlicher MIDI-Ausgang für SAM5504
                           ; 10.10.2017 Angepasst für KCPSM6, Inputs für Cancel Manual und HW-Sostenuto/Sustain auf PL Auxiliary
                           ; Pins schalten nach Masse!
                           ; Pin 6 = Bit 5 Sustain Upper
                           ; Pin 5 = Bit 4 Sostenuto Upper
                           ; Pin 4 = Bit 3 Sustain Lower
                           ; Pin 3 = Bit 2 Sostenuto Lower
                           ; Pin 2 = Bit 1 Cancel MIDI Kanal invert., 11 = Cancel Off, 10 = Cancel Upper,
                           ; Pin 1 = Bit 0 Cancel MIDI Kanal invert., 01 = Cancel Lower, 00 = Cancel Pedal
                           ;
                           CONSTANT c_corevers, 61                ; $60=SR4014, $61=Fatar, $62=Opto, $63=MIDI, $64=OrganScan61, $65=XB2-5
                           CONSTANT c_corevers_midionly, 63       ; zum Vergleichen im MIDI-Scan-Treiber
                           CONSTANT c_corerevi, 50                ; Revisionsnummer
                           CONSTANT c_dyn_threshold, 40           ; MIDI-Dynamikschwelle für full click
                           CONSTANT c_midi_mindyn, 10             ; MIDI-Minimaldynamik langsame Taste
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                           ; Je nach Tastaturumfang sind anzupassen:
                           CONSTANT c_maxkeys, 60'd               ; längste vorhandene Tastatur (44/49/61) +1
                           CONSTANT c_maxkeys_plus1, 61'd         ; längste vorhandene Tastatur (44/49/61) +1
                           CONSTANT c_maxkeys_8x8, 64'd           ; für Matrix-Abfrage
                           CONSTANT c_maxbasskeys, 25'd           ; Anzahl der Pedal-Tasten an AuxPort PL8
                           CONSTANT c_midi_firstkey, 24'd
                           CONSTANT c_midi_lastkey_plus1, 109'd
                           CONSTANT c_gen_firstkey, 36'd          ; Tonumfang INPUT MIDI-Notennummern
                           CONSTANT c_gen_lastkey_plus1, 97'd     ; 96+1 wg. COMPARE
                           CONSTANT c_midi_offset, 36'd           ; Offset zu unterster MIDI-Note "C" bei 5 Oktaven (default 36)
                           CONSTANT c_scankey_delay, 24'd         ; Delay pro Taste für 500 µs Scandurchlauf in SYNC-Ticks (20,833 µs)
                           ;
                           ;
                           ; ##############################################################################
                           ; ############################ MPX-RAM-Organisation ###########################
                           ; ##############################################################################
                           ;
                           ; Ein/Ausschalten der HX3-Tastenkontakte erfolgt durch Schreiben der
                           ; Kontaktdaten in ein Dual-Port-RAM, das sogerannte MPX-RAM.
                           ; Jede Taste(nspalte) belegt eine Adresse,
                           ; so dass das tiefste "C" immer Adresse 0 hat, das höchste "C" Adresse 60.
                           ; Für jedes Manual stehen 8 Bits des 18-Bit-Datenbusses zur Verfügung,
                           ; für das Pedal 2 (sonst ungenutzte Paritätsbits). Jeder Teil kann getrennt geschrieben/gelesen werden.
                           ; MPX-RAM besteht aus 16 Pages je 64 Worte, 16 Bit plus zwei "Parity"-Bits,
                           ; die hier für den Pedal-Status benutzt werden. Auswahl der Page über RAM_PAGE.
                           ; MSB, LSB und Parity-Bits können getrennt über STROBEs geschrieben werden.
                           ;
                           ; Page 0 dient direkt als Freigabe für Tastenkontakte, im FPGA als
                           ; zwei CONTACTS-Bytes für Upper- und Lower-Gating:
                           ;
                           ; ##### LOWER #####   ##### UPPER #####  -  Bytes
                           ; 7 MSN 4  3 LSN 0    7 MSN 4  3 LSN 0   -  Nibbles
                           ; #NOISE#  #STEAD#    #NOISE#  #STEAD#
                           ; - C B A  L C B A    - C B A  L C B A   -  Bits
                           ;
                           ; Dabei wird Wert ABC jeweils anhand des folgenden Schemas dekodiert,
                           ; mit ABC = Anzahl eingeschalteter Tastenkontakte lt. folgender Tabelle, L = Level-Bit (0 = halber Pegel)
                           ; ABC Kontakte Busbar 15..0
                           ; 0   0000000000000000, ; alle OFF
                           ; 1   0000000000100000, ; Stufe 1...
                           ; 2   0000000000100100,
                           ; 3   0000000010100100,
                           ; 4   0011000010100110,
                           ; 5   0011000111100110,
                           ; 6   1011101111101111,
                           ; 7   1111111111111111 ; bis Stufe 7, alle ON
                           ;
                           ; Es ist somit (ggf. für Opto/Hallsensor-Tastaturen) möglich, das Click-Noise- und Steady-Signal getrennt
                           ; in 8 Stufen und mit zwei Pegelstufen (halber/voller) nacheinander einzuschalten, um das Kontaktprellen
                           ; und den Kontakt-Übergangswiderstand zu simulieren.
                           ;
                           ; Verhalten Tastenkontakt-Bits nach Dekodierung ABC -> Kontakte aus obiger Tabelle
                           ; noise_bb_bit  steady_bb_bit  level_full_bit  Resultat
                           ; 0             0              0               OFF
                           ; 1             0              0               HALF NOISE
                           ; 0             1              0               HALF STEADY
                           ; 1             1              0               HALF NOISE, HALF STEADY
                           ; 0             0              1               OFF
                           ; 1             0              1               FULL NOISE
                           ; 0             1              1               FULL STEADY
                           ; 1             1              1               FULL STEADY
                           ;
                           ; Pedalkontakt CONT_PEDAL ist an Bit(0) angeschlossen, Bit (1) kann als Scratch dienen.
                           ; Die Nibbles können in pb_scanif.vhd einzeln gelesen werden!
                           ; PAGE 1 als Soft-Timer für Tastenkontakte
                           ; PAGE 2 als Soft-Timer für Noise
                           ; PAGEs 6 bis 15 können nach Belieben verwendet werden.
                           ;
                           ; MPX RAM_PAGE Offsets
                           ; Seitenaufteilung in 64-Byte-Seiten, Auswahl über RAM_PAGE
                           ;
                           CONSTANT c_page_vcontacts, 00          ; virtuelle Tastenkontakte, 0..60, direktes Lesen und Schreiben
                           CONSTANT c_page_dyntimer, 01           ; Dynamik-Timer 0..60 für Tastatur-Scan
                           CONSTANT c_page_noisetimer, 02         ; Noise-Timer 0..60
                           CONSTANT c_page_keystate, 03           ; State Machine Tastenspalte 0..60
                           CONSTANT c_page_velocity, 04           ; Über Timer-Berechnung ermittelte Keyboard-Dynamik für Tasten 0..60
                           CONSTANT c_page_earlystep, 05          ; Eigene Tastatur Early-Zustand für Tasten 0..60
                           CONSTANT c_page_latestep, 06           ; Eigene Tastatur 2 Stufen für Tasten 0..60, aus Dynamik errechnet
                           CONSTANT c_page_sostenuto, 07          ; Sostenuto-Flags 0..60
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; Portadressen bidirektional
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                           ; $00 bis $07 Einzelbits SCANPORT Eingang, für Opto und Fatar
                           CONSTANT SCANPIO1, 00                  ; Group Clock 4024/4051 MPX
                           CONSTANT SCANPIO2, 01                  ; Group Reset 4024/4024 MPX
                           CONSTANT SCANPIO3, 02                  ; Break 1st Contact von 4051, Upper
                           CONSTANT SCANPIO4, 03                  ; Make 2nd Contact von 4051, Upper
                           CONSTANT SCANPIO5, 04                  ; Key Clock 4017
                           CONSTANT SCANPIO6, 05                  ; Key Reset 4017
                           CONSTANT SCANPIO7, 06                  ; Break 1st Contact von 4051, Lower
                           CONSTANT SCANPIN8, 07                  ; Make 2nd Contact von 4051, Lower, nur Eingang!
                           ; $00 bis $07 Einzelbits AUXPORT Eingang, für OrganScan/HOAX5 mit 4014 und Bass13/25
                           CONSTANT AUXPIO1, 08                   ; Clock SR 4014
                           CONSTANT AUXPIO2, 09                   ; Parallel Load SR 4014
                           CONSTANT AUXPIO3, 0A                   ; Shift Out Upper SR 4014
                           CONSTANT AUXPIO4, 0B                   ; Shift Out Lower SR 4014
                           CONSTANT AUXPIO5, 0C                   ; Shift Out Pedal SR 4014
                           CONSTANT AUXPIO6, 0D                   ; frei für Debug-Zwecke
                           ;CONSTANT AUXPIO7, 0E                   ; ACHTUNG: Für Rotary-LED-PWM benutzt
                           CONSTANT AUXPIN8, 0F                   ; unbenutzt, nur Eingang!
                           ;
                           CONSTANT SCANPIN, 10                   ; Fatar Scan Port gesamt READ
                           CONSTANT SCANPORT, 10                  ; Fatar Scan Port gesamt WRITE
                           CONSTANT SCANPORT_DDR, 11              ; Fatar Scan Port Data Direction
                           CONSTANT AUXPIN, 18                    ; SR4014/Auxiliary Port gesamt READ
                           CONSTANT AUXPORT, 18                   ; SR4014/Auxiliary Port gesamt WRITE
                           CONSTANT AUXPORT_DDR, 19               ; SR4014/Auxiliary Port Data Direction
                           CONSTANT SWITCHPIN, 32                 ; Switches Port gesamt READ
                           CONSTANT SWITCHPORT, 28                ; Switches Port gesamt WRITE
                           CONSTANT SWITCHPORT_DDR, 29            ; Switches Port Data Direction
                           ; Output ports
                           CONSTANT c_strobe_mask, 20             ; für indirektes Schreiben
                           CONSTANT UPPER_STROBE, 20              ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Upper (1 Byte)
                           CONSTANT LOWER_STROBE, 21              ; Schreibzugriff erzeugt Write für Busbar- und Noise-Enables Lower (1 Byte)
                           CONSTANT PEDAL_STROBE, 22              ; Schreibzugriff erzeugt Write für Pedal-Bits (2 Bits)
                           CONSTANT MIDI_CMD, 30                  ; MIDI-Befehl
                           CONSTANT MIDI_DB1, 31
                           CONSTANT MIDI_DB2, 32
                           CONSTANT MIDI_STR, 33                  ; MIDI Strobe für AVR, neg. Flanke
                           CONSTANT STATUS, 34                    ; STATUS an AVR SPI, Bit 0 bis 3 durch PB schreibbar, Bit 4 und 5 direkt SPI MIDI FIFO STAT
                           CONSTANT KEYS_ON_UPR, 35               ; Bit 0: auf Upper sind Tasten gedrückt
                           CONSTANT KEYS_ON_LWR, 36               ; Bit 0: auf Lower sind Tasten gedrückt
                           ; CONSTANT BASS_ENV, 37                 ; UNUSED
                           CONSTANT PEDAL_DOWN, 38                ; Bit 0
                           CONSTANT PED_ACC_ENA, 39               ; für pedal click noise
                           CONSTANT MIDI_OUT_SEL, 3A              ; auf 4-fach Multiplexer
                           CONSTANT MIDI_USE_NEW_ROUTING, 3B      ; neues MIDI-Routing mit separatem Eingang 3 aktiv wenn '1', vom Scan-Treiber zu setzen
                           ; MIDI_OUT_SEL: 0 = MIDI_TX_DIN, 1 = MIDI_IN_1, 2 = MIDI_IN_2, 3 = MIDI_FROM_SAM (USB)
                           ; Universal-Timer, hier für Scan-Durchlauf, 255 = 5,22 ms
                           ; wird mit jedem SYNC alle 20,48 µs dekrementiert bis 0 erreicht
                           CONSTANT SCANTIMER_VAL, 3D             ; Schreiben des neuen Wertes startet Timer
                           CONSTANT SCANTIMER_ZERO, 3E            ; Flag wenn 0 erreicht
                           CONSTANT NOISE_FREQ, 3F                ; bestimmt Noise-Frequenz
                           CONSTANT RAM_PAGE, 40                  ; Seitenadresse zum einfacheren Zugriff, Page 0 = MPX Dual Port
                           CONSTANT RAM_ADDR, 41                  ; für alle Zugriffe gültig
                           CONSTANT RAM_WRDATA, 42                ; zu schreibende Daten
                           ;
                           CONSTANT MIDI_TX_DIN, 80               ; MIDI UART-Tx-FIFO an DIN MAIN OUT
                           CONSTANT MIDI_TX_SAM, 81               ; MIDI UART-Tx-FIFO an SAM5504 DSP
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; Input Ports
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; Flags für SPI-Empfang:
                           ; Bit 0 = Daten wurden geschrieben (wird durch Lesen der SPI-Register gelöscht)
                           ; Bit 1 = AVR-MIDI FIFO Daten im Buffer,
                           ; Bit 2 = AVR-MIDI FIFO Buffer halb voll
                           ; Bit 3 = AVR-MIDI FIFO Buffer voll
                           ;
                           CONSTANT FEATURE_SPI_FLAG, 30          ; war "0000000" & spiflag, jetzt "0000001" & spiflag wenn neues FPGA
                           CONSTANT TX_STATUS, 31                 ; Bit 0 = TX DIN (1) voll, Bit 1 = TX SAM (2) voll
                           CONSTANT c_read_mask, 34               ; für indirektes Lesen
                           CONSTANT RD_UPPER, 34                  ; Upper-Byte vom MPX-RAM
                           CONSTANT RD_LOWER, 35                  ; Lower-Byte vom MPX-RAM
                           CONSTANT RD_PEDAL, 36                  ; Pedal-Bits vom MPX-RAM (1:0)
                           CONSTANT MIDI_IN1, 38
                           CONSTANT MIDI_IN1_STATUS, 39           ; "0000" & midi_1_full & midi_1_half & midi_1_datapresent & '0';
                           CONSTANT MIDI_IN2, 3A
                           CONSTANT MIDI_IN2_STATUS, 3B           ; "0000" & midi_2_full & midi_2_half & midi_2_datapresent & '0';
                           CONSTANT MIDI_AVR, 3C                  ; MIDI vom AVR über SPI
                           CONSTANT MIDI_AVR_STATUS, 3D           ; "0000" & avrfifo_full & avrfifo_half & avrfifo_datapresent & avrmidiflag
                           ; Können benutzt werden, wenn FEATURE_SPI_FLAG = "0000001x" ist (neues FPGA mit eigenem FIFO für SAM5504)
                           ; und MIDI_USE_NEW_ROUTING $3B vom Scan-Treiber auf $01 gesetzt wurde
                           CONSTANT MIDI_IN_SAM, 37               ; MIDI IN SAM auf eigenem FIFO (neu, separat statt mit MIDI IN2 verANDet)
                           CONSTANT MIDI_SAM_STATUS, 33           ; "0000" & midi_3_full & midi_3_half & midi_3_datapresent & '0';
                           CONSTANT RND_NUMBER, 3F                ; Zufallswert 8 Bit
                           ; Werte vom AVR-SPI
                           CONSTANT SPI_MIDICH, 24                ; Adresse $04 von außen (AVR)
                           CONSTANT SPI_MIDIOPT, 25
                           CONSTANT SPI_SPLITMODE, 26
                           CONSTANT SPI_SPLITON, 27               ; 7 von außen (AVR)
                           CONSTANT SPI_SPLITPOINT, 28            ; 8 von außen (AVR)
                           CONSTANT SPI_CLICKLEN, 29
                           CONSTANT SPI_GENTRANSPOSE, 2A          ; 10 = Generator Transpose
                           CONSTANT SPI_CONFIG_1, 2B              ; 11 = EARLY_KEY (Bit 0), (LUBED_CONTACTS (Bit 1), VelocityFactor (Bit 7..2)
                           ; SPI_AVR_MIDI, 2C ; AVR-MIDI-Daten, FIFO-Eingang
                           CONSTANT SPI_KEYTRANSPOSE, 2D          ; Key Transpose (local keyboard)
                           CONSTANT SPI_MIDISEND_DISABLES, 2E     ; Bit 0..2 verhindern Senden der Manual-Daten wenn "1"
                           ;
                           CONSTANT c_state_idle, 00              ; für Tastenabfrage-Timer, OFF gesendet
                           CONSTANT c_state_forward, 01           ; für Tastenabfrage-Timer, zählend
                           CONSTANT c_state_stopped, 02           ; für Tastenabfrage-Timer, angehalten
                           CONSTANT c_state_reverse, 03           ; für Tastenabfrage-Timer, bewegt sich zurück
                           CONSTANT c_state_idle_pedal, 00        ; für Tastenabfrage-Timer, Ruhezustand
                           CONSTANT c_state_stop_pedal, 01        ; für Tastenabfrage-Timer, angehalten
                           ;
                           CONSTANT c_key_idle, 00                ; für Tastenabfrage, Ruhezustand
                           CONSTANT c_key_moving, 01              ; für Tastenabfrage, in Bewegung
                           CONSTANT c_key_dirty, 02               ; für Tastenabfrage, Ende erreicht (dirty)
                           CONSTANT c_key_on, 03                  ; für Tastenabfrage, Ende erreicht
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; Picoblaze Scratchpad Memory
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                           CONSTANT s_split_on, 00                ; Letzter Split-Zustand
                           CONSTANT s_splitpoint, 01              ; Tastennummer von SPI-AVR
                           CONSTANT s_splitmode, 02
                           CONSTANT s_transpose, 03               ; Tongenerator/MIDI-IN-Transpose
                           ;
                           CONSTANT s_keystatus_upper, 10         ; für Tastenabfrage, vorheriger Tastenzustand
                           CONSTANT s_keystatus_lower, 11
                           CONSTANT s_keystatus_pedal, 12
                           ;
                           ;
                           CONSTANT s_keycount_upper, 32'd
                           CONSTANT s_keycount_lower, 33'd
                           CONSTANT s_keycount_pedal, 34'd        ; Dummy für Pedal, nicht belegen!
                           ;
                           CONSTANT s_scan_key_save, 36'd
                           CONSTANT s_velocityfac, 38'd           ; Faktor für Timer-Dekrement
                           CONSTANT s_pedal_on, 39'd              ; Bass-Flag Trigger für Hüllkurve
                           CONSTANT s_midich, 40'd                ; eingestellter MIDI-Kanal
                           ;
                           CONSTANT s_switches_old, 43'd          ; kommt als Bit 1 von Split_ON (0000 00X0)
                           CONSTANT s_sustain_upr, 44'd
                           CONSTANT s_sustain_lwr, 45'd
                           ; 46 Dummy für Pedal, immer 0, nicht belegen!
                           CONSTANT s_sosten_upr, 47'd            ; Empfangenes CC 64, Sostenuto aktiv
                           CONSTANT s_sosten_lwr, 48'd
                           ; 49 Dummy für Pedal, immer 0, nicht belegen!
                           CONSTANT s_local_key, 50'd             ; für local out, enthält aktuelle Taste einschließlich Offset
                           CONSTANT s_local_dyn, 51'd
                           CONSTANT s_pedal_noisecounter, 52'd
                           CONSTANT s_scanloop_counter, 53'd
                           CONSTANT s_lastkey_on, 54'd            ; letzte gedrückte Taste für Split
                           CONSTANT s_clicklen, 55'd              ; Timer-Startwert
                           CONSTANT s_last_key_velocity, 56'd
                           ;
                           ;
                           CONSTANT s_vcont_upper, 61'd           ; gleichzeitig von Event gelesene Kontakt-Zustände
                           CONSTANT s_vcont_lower, 62'd
                           CONSTANT s_vcont_pedal, 63'd
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; Extended scratchpad memory bei KCPSM6, hier fuer MIDI, ab 64'd
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                           ; MIDI-Daten für Interpreter/Dispatcher
                           CONSTANT s_midi_cmd, 40                ;  = 64'd
                           CONSTANT s_midi_data1, 41
                           CONSTANT s_midi_data2, 42
                           CONSTANT s_midi_len, 43
                           CONSTANT s_midi_cmd_masked, 44         ; upper Nibble
                           CONSTANT s_midi_chan_masked, 45        ; lower Nibble
                           CONSTANT s_midi_activesensing, 46      ; Zähler/Timer für MIDI Active Sensing
                           CONSTANT s_midi_sam_has_fifo, 47       ; ist 01 wenn neues FPGA mit separatem SAM-FIFO
                           ; Indizierbare MIDI-Empfangs-Variablen für 4 MIDI-Eingänge
                           ; MIDI Command per Polling vom FIFO
                           CONSTANT c_midi_cmd_base, 50
                           CONSTANT s_midi_1_cmd, 50
                           CONSTANT s_midi_2_cmd, 51
                           CONSTANT s_midi_avr_cmd, 52
                           CONSTANT s_midi_sam_cmd, 53
                           ; MIDI Datenbyte 1 per Polling vom FIFO
                           CONSTANT c_midi_data1_base, 54
                           CONSTANT s_midi_1_data1, 54
                           CONSTANT s_midi_2_data1, 55
                           CONSTANT s_midi_avr_data1, 56
                           CONSTANT s_midi_sam_data1, 57
                           ; MIDI Datenbyte 2 per Polling vom FIFO
                           CONSTANT c_midi_data2_base, 58
                           CONSTANT s_midi_1_data2, 58
                           CONSTANT s_midi_2_data2, 59
                           CONSTANT s_midi_avr_data2, 5A
                           CONSTANT s_midi_sam_data2, 5B
                           ; MIDI ermittelte Soll-Länge
                           CONSTANT c_midi_len_base, 5C
                           CONSTANT s_midi_1_len, 5C
                           CONSTANT s_midi_2_len, 5D
                           CONSTANT s_midi_avr_len, 5E
                           CONSTANT s_midi_sam_len, 5F
                           ; MIDI-Datenbyte-Zähler
                           CONSTANT c_midi_counter_base, 60
                           CONSTANT s_midi_1_counter, 60
                           CONSTANT s_midi_2_counter, 61
                           CONSTANT s_midi_avr_counter, 62
                           CONSTANT s_midi_sam_counter, 63
                           ; MIDI-Datenempfangs-Flags
                           CONSTANT c_midi_rxflag_base, 64
                           CONSTANT s_midi_1_rxflag, 64
                           CONSTANT s_midi_2_rxflag, 65
                           CONSTANT s_midi_avr_rxflag, 66
                           CONSTANT s_midi_sam_rxflag, 67
                           ; MIDI-Datenempfang: System Commons und deren Daten ignorieren
                           CONSTANT c_midi_ignoreflag_base, 68
                           CONSTANT s_midi_1_ignoreflag, 68
                           CONSTANT s_midi_2_ignoreflag, 69
                           CONSTANT s_midi_avr_ignoreflag, 6A
                           CONSTANT s_midi_sam_ignoreflag, 6B
                           ; MIDI-Datenempfang: System Exclusive Flag
                           CONSTANT c_midi_SysExFlag_base, 6C
                           CONSTANT s_midi_1_SysExFlag, 6C
                           CONSTANT s_midi_2_SysExFlag, 6D
                           CONSTANT s_midi_avr_SysExFlag, 6E
                           CONSTANT s_midi_sam_SysExFlag, 6F
                           ;
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; Register Renames
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                           ; evt. für schnelleren Zugriff benutzen
                           NAMEREG sF, midi_cmd_idx
                           NAMEREG sE, midi_ignoreflag_idx
                           NAMEREG sD, midi_SysExFlag_idx
                           NAMEREG sC, midi_counter_idx
                           ; NAMEREG sB, midi_cmd_saved
                           ;
                           ; häufig benutzte Variablen
                           NAMEREG sA, sA_matrix_key              ; Für FatarScan-Abfrage, Taste innerhalb Gruppe, nur in local_ benutzt
                           NAMEREG s9, s9_manual_select           ; aktuelles Manual, 0 = upper, 1 = lower, 2 = bass
                           NAMEREG s8, s8_msb                     ; Zustand gedrückte Taste MIDI-Empfang, msb für Multiply
                           NAMEREG s7, s7_lsb                     ; Zustand gedrückte Taste eigene Manuale, lsb für Multiply
                           NAMEREG s6, s6_idx_ptr                 ; universeller Index-Zeiger, auch für page select
                           NAMEREG s5, s5_scan_key                ; aktuelle Taste, Zähler ab 0 bis Tastenanzahl
                           NAMEREG s4, s4_contacts                ; Für Event-Routine
                           NAMEREG s3, s3_key_status              ; Zustand gedrückte Taste Manual und allgemein
                           ; s0, s1, s2 als Universal-Akkus
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
               cold_start:
                           ; Einsprungpunkt nach Laden des Scan Cores
                           DISABLE INTERRUPT
                           CALL port_init
                           CALL scan_init
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                           LOAD s0, 00
                           STORE s0, s_pedal_noisecounter
                           STORE s0, s_scanloop_counter
                           STORE s0, s_sustain_upr
                           STORE s0, s_sustain_lwr
                           STORE s0, s_sosten_upr
                           STORE s0, s_sosten_lwr
                main_loop:
                           CALL midi_rx_check                     ; MIDI-Daten empfangen? - ca. 1,7 µs
                           ; auf Scan-Freigabe durch Timer warten
                           INPUT s0, SCANTIMER_ZERO               ; auf Scan-Freigabe warten
                           COMPARE s0, 00                         ; warte auf Timer-Tick
                           JUMP Z, main_loop
                           ; Gesamtbedarf mit Pedal 380 µs
                           CALL pulse_test                        ; TEST
                           CALL local_scan_manuals                ; alle Manualtasten in RAM eintragen - ca. 200µs plus 40µs für Pedal
                           ;
                           CALL scan_config                       ; Parameter-Änderungen? - ca. 3,4µs
                           CALL handle_sustain_switches           ; Sustain/Sostenuto-Eingangspins
                           CALL scan_wait_init                    ; Scan-Timer neu starten
                           ;
                           CALL pulse_test                        ; TEST
                           CALL update_noisetimers                ; alle Timer updaten - ca. 26 µs, in 1 ms Abstand
                           CALL pulse_test                        ; TEST
                           ;
                           ; CALL active_sensing                   ; ca. 1,3 µs
                           ; MIDI hat Timing-mäßig Vorrang vor eigener Tastatur,
                           ; um Buffer-Überläufe zu verhindern
                           CALL midi_rx_check                     ; MIDI-Daten empfangen? - ca. 1,7 µs
                           CALL event_handling                    ; Tasten auswerten, ca. 106 µs
                           CALL pulse_test                        ; TEST
                           ;
                           JUMP main_loop
                           ;
                           ; ###############################################################################
                           ; +++++++++++++++++++++ Scanboard-spezifischer Teil, +++++++++++++++++++++++++++
                           ; +++++++++++++++++++++++++++++ Hauptschleife ++++++++++++++++++++++++++++++++++
                           ; ###############################################################################
                           ;
  handle_sustain_switches:
                           ; abhängig vom PL16-Bits Flag in s_sustain_xxx oder s_sosten_xxx setzen/löschen
                           INPUT s3_key_status, SWITCHPIN         ; Bit 5 ist Sustain upper, Bit 3 lower
                           XOR s3_key_status, FF                  ; invertiert!
                           AND s3_key_status, 3C
                           FETCH s0, s_switches_old               ; alter Schalterzustand
                           XOR s0, s3_key_status                  ; geänderte Bits jetzt auf 1 in s0
                           RETURN Z                               ; nichts geändert
                           ; Es hat sich etwas geändert, jetzt einzeln verzweigen
                           FETCH s0, s_switches_old
                           AND s0, 20                             ; Pin 6 = Bit 5 Sustain Upper
                           LOAD s1, s3_key_status
                           AND s1, 20                             ; Pin 6 = Bit 5 Sustain Upper
                           XOR s0, s1                             ; geändertes Bit jetzt auf 1
                           CALL NZ, handle_sust_upr_changed
                           ;
                           FETCH s0, s_switches_old
                           AND s0, 10                             ; Pin 5 = Bit 4 Sostenuto Upper
                           LOAD s1, s3_key_status
                           AND s1, 10                             ; Pin 5 = Bit 4 Sostenuto Upper
                           XOR s0, s1                             ; geändertes Bit jetzt auf 1
                           CALL NZ, handle_sosten_upr_changed
                           ;
                           FETCH s0, s_switches_old
                           AND s0, 08                             ; Pin 4 = Bit 3 Sustain Lower
                           LOAD s1, s3_key_status
                           AND s1, 08                             ; Pin 4 = Bit 3 Sustain Lower
                           XOR s0, s1                             ; geändertes Bit jetzt auf 1
                           CALL NZ, handle_sust_lwr_changed
                           ;
                           FETCH s0, s_switches_old
                           AND s0, 04                             ; Pin 3 = Bit 2 Sostenuto Lower
                           LOAD s1, s3_key_status
                           AND s1, 04                             ; Pin 3 = Bit 2 Sostenuto Lower
                           XOR s0, s1                             ; geändertes Bit jetzt auf 1
                           CALL NZ, handle_sosten_lwr_changed
                           ;
                           STORE s3_key_status, s_switches_old
                           RETURN
                           ;
                           ; aktuelles Switch-Bit in s1
  handle_sust_upr_changed:
                           LOAD s9_manual_select, 00
                           JUMP handle_sustain_changed_0
  handle_sust_lwr_changed:
                           LOAD s9_manual_select, 01
 handle_sustain_changed_0:
                           CALL NZ, test_s1_set_s2                ; s2 auf $7F wenn ein Switch-Bit gesetzt ist
                           LOAD s6_idx_ptr, s_sustain_upr
                           ADD s6_idx_ptr, s9_manual_select
                           STORE s2, (s6_idx_ptr)
                           LOAD s1, 40                            ; Sustain-Controller
                           JUMP local_send_fs
                           ;
                           ;
handle_sosten_upr_changed:
                           LOAD s9_manual_select, 00
                           JUMP handle_sosten_changed_0
handle_sosten_lwr_changed:
                           LOAD s9_manual_select, 01
  handle_sosten_changed_0:
                           ;
                           CALL NZ, test_s1_set_s2                ; s2 auf $7F wenn ein Switch-Bit gesetzt ist
                           LOAD s6_idx_ptr, s_sosten_upr
                           ADD s6_idx_ptr, s9_manual_select
                           STORE s2, (s6_idx_ptr)
                           LOAD s1, 45                            ; HOLD2-Sostenuto-Controller
                           JUMP local_send_fs
                           ;
           test_s1_set_s2:
                           LOAD s2, 00
                           TEST s1, 3C
                           RETURN Z
                           LOAD&RETURN s2, 7F
                           ;
                           ; Fußschalter-MIDI senden. Hier kommen wir nur hin, wenn sich etwas geändert hat.
                           ; aktueller Schalterzustand in s2, Controller in s1, Kanal in s9_manual_select
            local_send_fs:
                           INPUT s0, SPI_MIDIOPT                  ; Bit 7 (MSB): USE SOST/SUSTAIN
                           AND s0, 80
                           RETURN Z
                           LOAD s8_msb, s1
                           FETCH s0, s_midich                     ; eingestellter Kanal
                           ADD s0, s9_manual_select               ; Manual-Nummer addieren
                           OR s0, B0                              ; MIDI CC senden
                           CALL midi_tx_s0
                           LOAD s0, s8_msb                        ; war vorher s1 = Controllernummer
                           CALL midi_tx_s0
                           LOAD s0, s2                            ; Wert senden
                           JUMP midi_tx_s0                        ; weiter mit midi_tx_s0
                           ;
                           ;
                           ; ###############################################################################
                           ; ################################ SCAN LOOP ####################################
                           ; ###############################################################################
                           ;
                           ; ------------------------------------------------------------------------------
                           ; NEUE Manual-Loops, Zeitbedarf ca. 200 µs bei 600 ns Einschwingeit pro Gruppe
                           ; ------------------------------------------------------------------------------
                           ; Neue, schnellere Scan-Abfrage wg. Trägheit der Dioden-Matrix
                           ; Vorher (#46): Wartezeit nach jeder einzelnen Taste nötig wg. Settle Time der Diodenmatrix
                           ;
                           ; Jetzt wird 4051-Multiplexer schnell inkrementiert und alle 8 Tasten der 4017 (neue Diodengruppe),
                           ; d.h. Settle Time ist nur noch alle 8 Tasten notwendig.
                           ;
                           ; Problem ist, dass die abgefragten Tasten wg. der alten Matrix dann nicht aufeinander folgen,
                           ; sondern im Abstand von 8 Tasten. Register s5_scan_key wird deshalb getrennt mitgeführt.
                           ;
                           ; Pedal-SR wird jetzt grundsätzlich getrennt abgefragt, ca. 40 µs
                           ; ------------------------------------------------------------------------------
                           ;
       local_scan_manuals:
                           ; Tastenzustand aller Manuale ermitteln und behandeln
                           ; Zeitbedarf ca. 200 µs (neu!) für Manuale, plus 40 µs für Pedal
                           CALL pulse_reset_keys                  ; Reset 4024, Pin 2 (D1), Reset 4017, Pin 6 (D5)
                           FETCH s0, s_split_on
                           AND s0, 03
                           JUMP Z, local_scanloop_nosplit         ; Split OFF
                           ; verschiedene SChleifen je nach Splitmode
                           FETCH s0, s_splitmode
                           COMPARE s0, 00
                           JUMP Z, local_scanloop_split_0         ; 0 = Pedal to Lower
                           COMPARE s0, 01
                           JUMP Z, local_scanloop_split_1         ; 1 = Lower to Upper
                           COMPARE s0, 02
                           JUMP Z, local_scanloop_split_2         ; 2 = Pedal to Upper
                           COMPARE s0, 03
                           JUMP Z, local_scanloop_split_3         ; 3 = Lower to Upper +1 Oktave
                           COMPARE s0, 04
                           JUMP Z, local_scanloop_split_4         ; 4 = Lower to Upper +2 Oktaven
                           JUMP local_scanloop_split_5            ; 5 = Add Pedal to Lower
                           ;
                           ; ------------------------------------------------------------------------------
                           ; Tastenabfrage-Schleifen für verschiedene Split-Modi
                           ; ------------------------------------------------------------------------------
                           ;
                           ; Split Modes:
                           ; 0 = Pedal to Lower
                           ; 1 = Lower to Upper
                           ; 2 = Pedal to Upper
                           ; 3 = Lower to Upper +1 Oktave
                           ; 4 = Lower to Upper +2 Oktaven
                           ; 5 = Add Pedal to Lower
                           ;
   local_scanloop_split_0:
                           ; 0 = Pedal to Lower
                           CALL local_handle_upper
                           CALL local_scan_split_0
                           CALL pulse_next_key                    ; erhöht sA_matrix_key und s5_scan_key um 1
                           COMPARE sA_matrix_key, c_maxkeys_8x8
                           JUMP NZ, local_scanloop_split_0
                           RETURN                                 ; kein Pedal abfragen!
                           ;
       local_scan_split_0:
                           FETCH s0, s_splitpoint
                           COMPARE s5_scan_key, s0
                           JUMP NC, local_handle_lower            ; JUMP wenn s5_scan_key > splitpoint
                           COMPARE s5_scan_key, c_maxbasskeys
                           RETURN NC                              ; wenn s5_scan_key > c_maxbasskeys
                           CALL local_get_lower                   ; Mode 0, Lower manual key auf Pedal schreiben
                           JUMP local_write_pedal
                           ;
   local_scanloop_split_1:
                           ; 1 = Lower to Upper
                           CALL local_scan_split_1
                           CALL pulse_next_key                    ; erhöht sA_matrix_key um 1 und s5_scan_key um 8 oder 1
                           COMPARE sA_matrix_key, c_maxkeys_8x8
                           JUMP NZ, local_scanloop_split_1
                           JUMP local_scan_pedal
                           ;
       local_scan_split_1:
                           FETCH s0, s_splitpoint
                           COMPARE s5_scan_key, s0
                           JUMP NC, local_handle_upper            ; JUMP wenn s5_scan_key > splitpoint
                           ; Mode 1, Upper manual key auf Lower schreiben
                           CALL local_get_upper                   ; Mode 1, Upper manual key auf Lower schreiben
                           LOAD s8_msb, 00                        ; Octave Transpose 0
                           JUMP local_write_lower_plus_s8
                           ;
   local_scanloop_split_2:
                           ; 2 = Pedal to Upper
                           CALL local_handle_lower
                           CALL local_scan_split_2
                           CALL pulse_next_key                    ; erhöht sA_matrix_key um 1 und s5_scan_key um 8 oder 1
                           COMPARE sA_matrix_key, c_maxkeys_8x8
                           JUMP NZ, local_scanloop_split_2
                           RETURN                                 ; kein Pedal abfragen!
                           ;
       local_scan_split_2:
                           FETCH s0, s_splitpoint
                           COMPARE s5_scan_key, s0
                           JUMP NC, local_handle_upper            ; JUMP wenn s5_scan_key > splitpoint
                           COMPARE s5_scan_key, c_maxbasskeys
                           RETURN NC                              ; wenn s5_scan_key > c_maxbasskeys
                           CALL local_get_upper                   ; Mode 2, Upper manual key auf Pedal schreiben
                           JUMP local_write_pedal
                           ;
   local_scanloop_split_3:
                           ; 3 = Lower to Upper +1 Oktave
                           CALL local_scan_split_3
                           CALL pulse_next_key                    ; erhöht sA_matrix_key um 1 und s5_scan_key um 8 oder 1
                           COMPARE sA_matrix_key, c_maxkeys_8x8
                           JUMP NZ, local_scanloop_split_3
                           JUMP local_scan_pedal
                           ;
       local_scan_split_3:
                           FETCH s0, s_splitpoint
                           COMPARE s5_scan_key, s0
                           JUMP NC, local_handle_upper            ; JUMP wenn s5_scan_key > splitpoint
                           CALL local_get_upper                   ; Mode 3, Upper manual key +12 auf Lower schreiben
                           LOAD s8_msb, 12'd                      ; + 1 Oktave
                           JUMP local_write_lower_plus_s8
                           ;
   local_scanloop_split_4:
                           ; 4 = Lower to Upper +2 Oktaven
                           CALL local_scan_split_4
                           CALL pulse_next_key                    ; erhöht sA_matrix_key um 1 und s5_scan_key um 8 oder 1
                           COMPARE sA_matrix_key, c_maxkeys_8x8
                           JUMP NZ, local_scanloop_split_4
                           JUMP local_scan_pedal
                           ;
       local_scan_split_4:
                           FETCH s0, s_splitpoint
                           COMPARE s5_scan_key, s0
                           JUMP NC, local_handle_upper            ; JUMP wenn s5_scan_key > splitpoint
                           LOAD s8_msb, 24'd                      ; + 2 Oktaven
                           JUMP local_write_lower_plus_s8
                           ;
   local_scanloop_split_5:
                           ; 5 = Add Pedal to Lower
                           CALL local_handle_upper
                           CALL local_handle_lower
                           CALL local_scan_split_5
                           CALL pulse_next_key                    ; erhöht sA_matrix_key um 1 und s5_scan_key um 8 oder 1
                           COMPARE sA_matrix_key, c_maxkeys_8x8
                           JUMP NZ, local_scanloop_split_5
                           RETURN                                 ; kein Pedal abfragen!
                           ;
       local_scan_split_5:
                           FETCH s0, s_splitpoint
                           COMPARE s5_scan_key, s0
                           RETURN NC
                           CALL local_get_lower
                           JUMP local_write_pedal                 ; Lower key auch auf Pedal schreiben
                           ;
   local_scanloop_nosplit: ; unsplitted, ca. 200µs Gesamtzeit ohne Pedal (+40µs)
                           CALL local_handle_upper
                           CALL local_handle_lower
                           CALL pulse_next_key                    ; erhöht sA_matrix_key um 1 und s5_scan_key um 8 oder 1
                           COMPARE sA_matrix_key, c_maxkeys_8x8
                           JUMP NZ, local_scanloop_nosplit
                           ; weiter mit Pedal-Loop local_scan_pedal
                           ;
                           ; ------------------------------------------------------------------------------
                           ; Pedal-Loop, ca. 40 µs mit 160 ns Impulsen
                           ; ------------------------------------------------------------------------------
                           ;
         local_scan_pedal:
                           CALL pulse_srload_pedal                ; SR laden mit aktuellen Pedal-Tastenstellungen
     local_scanloop_pedal:
                           CALL local_get_pedal
                           call local_write_pedal
                           CALL pulse_next_pedal                  ; erhöht s5_scan_key
                           COMPARE s5_scan_key, c_maxbasskeys
                           JUMP NZ, local_scanloop_pedal
                           RETURN
                           ;
                           ; ###############################################################################
                           ; # Impulse für Hardware erzeugen und s5_scan_key, sA_matrix_key inkrementieren #
                           ; ###############################################################################
                           ;
                           ; NEU: Vertauschte Reihen und Spalten,
                           ; damit nicht nach jeder Taste eine Einschwingzeit nötig ist
                           ;
                           ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; FATAR SCAN und PEDAL
                           ; Inc 4024,   SCANPIO1 (D0) - Key-Select innerhalb Gruppe, 0..7
                           ; Reset 4024, SCANPIO2 (D1)
                           ; Inc 4017,   SCANPIO5 (D4) - Gruppen-Select 0..7
                           ; Reset 4017, SCANPIO6 (D5)
                           ; +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                           ; Hilfsroutinen: Zubehör für Scan-Routinen, Initialisierungen
                           ;
                port_init:
                           ; Scan-Ports initialisieren
                           LOAD s0, 33                            ; für Fatar-/Opto-Interface
                           OUTPUT s0, SCANPORT_DDR
                           LOAD s0, 23                            ; für Bass/Aux-Interface, Bit 5 (AUXPIO6) für Timing-Debug
                           OUTPUT s0, AUXPORT_DDR
                           LOAD s0, 00                            ; Sustainpedal, alles Eingänge
                           OUTPUT s0, SWITCHPORT_DDR
                           RETURN
                           ;
           pulse_next_key:
                           ; Inc 4024 MPX counter, nach 8 Pulsen inc 4017
                           ; erhöht sA_matrix_key um 1 und s5_scan_key um 8 oder 1
                           ; Nötig für neue, schnellere Scan-Abfrage wg. Trägheit der Dioden-Matrix
                           ; Jetzt wird 4051-Multiplexer schnell inkrementiert und alle 8 Tasten der 4017 (neue Diodengruppe)
                           ; Problem ist, dass die abgefragten Tasten wg. der alten Matrix dann nicht aufeinander folgen,
                           ; sondern im Abstand von 8 Tasten. Register s5_scan_key wird deshalb getrennt mitgeführt.
                           LOAD s0, 01
                           OUTPUT s0, SCANPIO1                    ; Inc 4024, Pin 1 (D0) pos. Impuls
                           ADD s5_scan_key, 08                    ; 8 Tasten weiter wg. historischer Matrix
                           LOAD s0, 00                            ; s1 ist jetzt 0
                           ; LOAD s0, 00                           ; NOP, falls CMOS-4024
                           OUTPUT s0, SCANPIO1                    ; Pin 1 (D0) auf 0
                           LOAD s0, sA_matrix_key
                           AND s0, 07
                           COMPARE s0, 07                         ; 8 Tasten gescannt?
                           CALL Z, pulse_next_keygroup            ; wenn ja, nächste Diodengruppe (s5_scan_key ++1)
                           AND s5_scan_key, 3F                    ; 6-Bit-Zähler 0..63
                           ADD sA_matrix_key, 01
                           RETURN
                           ;
      pulse_next_keygroup:
                           ; Inc 4017 Johnson counter, nächste Tasten-/Diodengruppe (alle 8 Tasten)
                           LOAD s0, 01
                           OUTPUT s0, SCANPIO5                    ; FatarScan 4017 Inc
                           ADD s5_scan_key, 01                    ; 1 Taste weiter wg. historischer Matrix
                           LOAD s0, 00                            ; s0 ist jetzt 0
                           ; LOAD s0, 00                           ; NOP, falls CMOS-4017
                           OUTPUT s0, SCANPIO5                    ; Reset aufheben
                           JUMP pulse_settle_delay                ; Einschwingzeit Diodenmatrix etwa 600-700 ns, s0 ist jetzt 00
                           ;
         pulse_reset_keys:
                           ; pos. Impuls auf Scanport Pin 2 (4024) und 6 (4017), s5_scan_key und sA_matrix_key auf 0
                           LOAD s0, 01
                           OUTPUT s0, SCANPIO2
                           OUTPUT s0, SCANPIO6
                           LOAD s5_scan_key, 00                   ; s5_scan_key und sA_matrix_key auf 0
                           LOAD sA_matrix_key, 00
                           LOAD s0, 00
                           OUTPUT s0, SCANPIO2
                           OUTPUT s0, SCANPIO6
                           JUMP pulse_settle_delay                ; Einschwingzeit Diodenmatrix etwa 600-700 ns, s0 ist jetzt 00
                           ;
       pulse_srload_pedal:
                           ; SR-Register übernehmen (synchron), s5_scan_key und sA_matrix_key auf 0
                           ; Am SR-Ausgang Q8 erscheint die unterste Taste (C)
                           LOAD s0, 01
                           OUTPUT s0, AUXPIO2                     ; SR-Load Enable
                           LOAD s0, 01                            ; Setup-Zeit für SR-Load
                           LOAD s0, 01                            ; 1 Befehl/Taktzyklus = 40,7 ns
                           LOAD s0, 01                            ; NOPs für 160ns Setup (typ. 90ns)
                           OUTPUT s0, AUXPIO1                     ; SR-Clk-Impuls für SR-Load
                           LOAD s5_scan_key, 00                   ; s5_scan_key und sA_matrix_key auf 0
                           LOAD sA_matrix_key, 00
                           LOAD s0, 00                            ; NOPs für 160ns Impuls (typ. 90ns)
                           OUTPUT s0, AUXPIO1
                           OUTPUT s0, AUXPIO2
                           RETURN
                           ;
         pulse_next_pedal:
                           ; SR-Daten weiterschieben, beginnend mit unterster Taste
                           ; erhöht s5_scan_key um 1
                           LOAD s0, 01
                           OUTPUT s0, AUXPIO1                     ; SR-Clk-Impuls für SR-Load
                           ADD s5_scan_key, 01                    ; nächste Pedal-Taste
                           ADD sA_matrix_key, 01                  ; hier bislang nicht gebraucht
                           LOAD s0, 00                            ; NOPs für 160ns Impuls (typ. 90ns)
                           OUTPUT s0, AUXPIO1
                           RETURN
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
       pulse_settle_delay:
                           LOAD s0, 05                            ; Delay-Zeit, (n + 1) * 81,4 + 81,4 ns = 569 ns mit n = 5
  pulse_settle_delay_loop:
                           SUB s0, 01                             ; 40,7 ns pro Befehl, 81,4 ns pro Schleifenduchlauf
                           JUMP NZ, pulse_settle_delay_loop
                           RETURN                                 ; nochmal 40,7 ns für RETURN
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
               pulse_test:
                           CALL pulse_test_on                     ; Test für Timing-Analyse
                           CALL pulse_settle_delay
           pulse_test_off:
                           LOAD s0, 00
                           OUTPUT s0, AUXPIO6                     ; Test für Timing-Analyse
                           RETURN
            pulse_test_on:
                           LOAD s0, 01
                           OUTPUT s0, AUXPIO6                     ; Test für Timing-Analyse
                           RETURN
                           ;
                           ; ------------------------------------------------------------------------------
                           ; Für Split-Bedienung: auf Loslassen aller Tasten warten
                           ; ------------------------------------------------------------------------------
                           ;
       wait_keys_released:
                           ; auf Loslassen aller Tasten aller Manuale warten
                           LOAD s8_msb, 00                        ; s3_key_status aller Tasten in s8_msb sammeln (OR'ed)
                           CALL wait_keys_in_s8
                           COMPARE s8_msb, 00                     ; keine Tasten mehr gedrückt?
                           JUMP NZ, wait_keys_released
                           RETURN
                           ;
          wait_keys_in_s8:
                           CALL pulse_reset_keys                  ; SR-Daten Pedal übernehmen, Reset 4024, Pin 2 (D1), Reset 4017, Pin 6 (D5)
           wait_keys_loop:
                           ; Tastenzustand aktuelle Tastenspalte ermitteln und in s8_msb sammeln (OR'ed)
                           CALL local_get_upper
                           OR s8_msb, s3_key_status
                           CALL local_get_lower
                           OR s8_msb, s3_key_status
                           CALL pulse_next_key                    ; erhöht sA_matrix_key um 1 und s5_scan_key um 8 oder 1
                           COMPARE sA_matrix_key, c_maxkeys_8x8   ; alle Tasten abgefragt?
                           JUMP NZ, wait_keys_loop
                           RETURN
                           ;
                           ; ------------------------------------------------------------------------------
                           ; Manual-Tastenzustände holen
                           ; 0 = Taste AUS
                           ; 1 = Kontakt 1. Schließer
                           ; 2 = Kontakt 2. Schließer
                           ; 3 = beide Kontakte, Taste voll gedrückt
                           ; ------------------------------------------------------------------------------
                           ;
                           ; Tastenzustand in s3_key_status holen - abhängig vom Scan-Board
          local_get_upper:
                           INPUT s3_key_status, SCANPIO3          ; 1. Schließer
                           INPUT s1, SCANPIO4                     ; 2. Schließer
                           SL0 s1
                           OR s3_key_status, s1
                           RETURN
          local_get_lower:
                           INPUT s3_key_status, SCANPIO7          ; 1. Schließer
                           INPUT s1, SCANPIN8                     ; 2. Schließer
                           SL0 s1
                           OR s3_key_status, s1
                           RETURN
          local_get_pedal:
                           INPUT s3_key_status, AUXPIO5           ; Pedalkontakt
                           XOR s3_key_status, 01                  ; ist jetzt 0 oder 1, keine Dynamik!
                           LOAD s1, s3_key_status
                           SL0 s1                                 ; 2. Kontakt simulieren
                           OR s3_key_status, s1
                           RETURN
                           ;
                           ;
                           ; ###############################################################################
                           ; ############################## LOCAL KEY HANDLING #############################
                           ; ###############################################################################
                           ;
                           ; Split Mode:
                           ; 0 = Pedal to Lower
                           ; 1 = Lower to Upper
                           ; 2 = Pedal to Upper
                           ; 3 = Lower to Upper +1 Oktave
                           ; 4 = Lower to Upper +2 Oktaven
                           ; 5 = Add Pedal to Lower
                           ;
                           ; -------------------------------- UPPER/LOWER ---------------------------------
                           ;
       local_handle_upper:
                           CALL local_get_upper                   ; Tastenzustand in s3_key_status holen
        local_write_upper:
                           LOAD s9_manual_select, 00              ; Upper ausgewählt
                           FETCH s0, s_transpose
                           ADD s0, s5_scan_key
                           ; Falls Bits 4 in SPI_SPLITON gesetzt, Oktav-Shift ausführen (MAG Organs 4-Oktaven-Modell)
                           FETCH s1, s_split_on
                           TEST s1, 10                            ; AND -> Z-Flag, Bit 4
                           CALL NZ, local_sub12_s0                ; MAG Mini, Octave Shift?
                           STORE s0, s_local_key                  ; Für Event-MPX und MIDI Send
                           JUMP local_states                      ; und zurück
                           ;
       local_handle_lower:
                           CALL local_get_lower                   ; Tastenzustand in s3_key_status holen
                           LOAD s8_msb, 00                        ; Octave Transpose 0
local_write_lower_plus_s8:
                           LOAD s9_manual_select, 01              ; Lower ausgewählt
                           FETCH s0, s_transpose
                           ADD s0, s5_scan_key
                           ; Falls Bit 5 in SPI_SPLITON gesetzt, Oktav-Shift ausführen (MAG Organs 4-Oktaven-Modell)
                           FETCH s1, s_split_on
                           TEST s1, 20                            ; AND -> Z-Flag, Bit 5
                           CALL NZ, local_sub12_s0                ; MAG Mini, Octave Shift?
                           ADD s0, s8_msb
                           STORE s0, s_local_key                  ; Für Event-MPX und MIDI Send
                           JUMP local_states                      ; und zurück
                           ;
           local_sub12_s0: ; Shift Upper -1 Oktave auf s0
                           SUB s0, 12'd                           ; transp. Key in s0
                           RETURN
                           ;
                           ; --------------------------------- PEDAL --------------------------------------
                           ;
        local_write_pedal:
                           COMPARE s5_scan_key, c_maxbasskeys
                           RETURN NC                              ; wenn s5_scan_key > c_maxbasskeys
                           INPUT s0, SPI_CONFIG_1                 ; Early-Action-Mode?
                           TEST s0, 01                            ; AND -> Z-Flag
                           JUMP NZ, local_write_pedal_1           ; Wenn Early Action ON
                           SR0 s3_key_status                      ; nur Schließer 2 berücksichtigen
      local_write_pedal_1:
                           AND s3_key_status, 01
                           LOAD s9_manual_select, 02              ; für MIDI OUTPUT Lower
                           FETCH s0, s_transpose
                           ADD s0, s5_scan_key
                           STORE s0, s_local_key                  ; Für Event-MPX und MIDI Send
                           ; weiter mit local_states_pedal und dann zurück
                           ; JUMP local_states_pedal
                           ;
                           ; ##############################################################################
                           ; ############# MIDI-Routinen für Scan-Events bei Keyboard-Abfrage #############
                           ; ################## sollte bei allen Scan-Boards gleich sein ##################
                           ; ##############################################################################
                           ;
                           ; -------------------------- Mealy-Zustandsautomat -----------------------------
                           ;
                           ; State in s2: c_state_idle, c_state_stopped
                           ;
                           ; ------------------------------------------------------------------------------
                           ;
       local_states_pedal:
                           ; Pedal hat nur 1 Bit im RAM, deshalb andere State Machine
                           CALL local_rd_state_s2                 ; Timer-State dieser Taste in s2
                           ; auf derzeitigen Zustand verteilen
                           COMPARE s2, c_state_idle
                           JUMP Z, local_idle_pedal
                           JUMP local_stop_pedal
                           ;
         local_idle_pedal:
                           COMPARE s3_key_status, c_key_idle      ; Hat Taste mindestens ersten Kontakt erreicht?
                           JUMP NZ, local_stop_pedal              ; wenn ja, in Counting-State gehen
                           RETURN                                 ; ist bereits in Ruhestellung, nichts machen
                           ;
     local_idle_pedal_off: ; Erstmals Ruhestellung
                           LOAD s2, c_state_idle_pedal            ; nächster Timer-State: Idle, OFF gesendet
                           CALL local_wr_state_s2
                           LOAD s3_key_status, c_key_idle
                           CALL local_wr_early_s3
                           JUMP local_states_off                  ; Eintragen, MIDI OFF senden und Ende
                           ;
         local_stop_pedal: ; Kontakt erreicht
                           COMPARE s3_key_status, c_key_idle
                           JUMP Z, local_idle_pedal_off           ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                           COMPARE s2, c_state_stop_pedal         ; bereits gestoppt und gesendet?
                           RETURN Z                               ; nichts machen, wenn bereits gestoppt
                           LOAD s2, c_state_stop_pedal
                           CALL local_wr_state_s2                 ; neuer Timer-State: c_state_stopped
                           LOAD s3_key_status, c_key_on
                           CALL local_wr_early_s3                 ; neuer Timer-State: c_state_stopped
                           JUMP local_states_on_pedal             ; Eintragen, MIDI ON senden und Ende
                           ;
                           ; -------------------------- Mealy-Zustandsautomat -----------------------------
                           ;
                           ; State in s2: c_state_idle, c_state_forward, c_state_stopped, c_state_reverse
                           ;
                           ; ------------------------------------------------------------------------------
                           ;
             local_states:
                           ; Zustand der State Machine holen, wg. Geschwindigheit hier separat
                           CALL local_rd_state_s2                 ; Timer-State dieser Taste in s2
                           ; auf derzeitigen Zustand verteilen
                           COMPARE s2, c_state_idle
                           JUMP Z, local_idle
                           COMPARE s2, c_state_forward
                           JUMP Z, local_forward
                           COMPARE s2, c_state_reverse
                           JUMP Z, local_reverse
                           JUMP local_stopped                     ; s2 kann hier nur noch c_state_stopped sein
                           ;
                           ; ------------------------------- State "Idle" ---------------------------------
                           ;
           local_idle_off:
                           ; Erstmals Ruhestellung, Dyntimer löschen
                           LOAD s0, FF
                           CALL local_wr_dyntimer_s0
                           LOAD s2, c_state_idle                  ; nächster Timer-State: Idle, OFF gesendet
                           CALL local_wr_state_s2
                           JUMP local_wr_early_s3                 ; aktuellen Zustand für Early Key in RAM speichern
                           ;
               local_idle:
                           COMPARE s3_key_status, c_key_idle      ; Hat Taste mindestens ersten Kontakt erreicht?
                           JUMP NZ, local_forward                 ; wenn ja, in Counting-State gehen
                           RETURN                                 ; nichts machen
                           ;
                           ; ------------------------------ State "Forward" --------------------------------
                           ;
            local_forward:
                           ;
                           ; Nur 1. Kontakt erreicht: Solange Taste in Bewegung ist, Timerwert verringern
                           CALL local_rd_dyntimer_s0              ; gelesenert Dyntimer-Wert in s0
                           FETCH s1, s_velocityfac                ; 0..31
                           CALL mult_soft_s0_s1                   ; s0 x s1 => s8_msb, s7_lsb, s0 bleibt bestehen
                           ; Subtrahend (= Timerwert * s_velocityfac div 256) jetzt in s8_msb
                           ; 1/t-Berechnung über log. fallende Kurve: s0 <= s0 - (s0 * s_velocityfac div 256) - 1
                           ; Subtrahend in s8_msb wird irgendwann 0, es würde in s0 ein Rest bleiben (s_velocityfac - 1)
                           COMPARE s8_msb, 00
                           CALL Z, load_s8_with_01                ; wenn 0, auf 1 setzen, Subtrahend nicht 0 werden lassen
                           SUB s0, s8_msb                         ; Timer um (Timerwert * s_velocityfac div 256) dekrementieren
                           ; C gesetzt wenn <0, sehr langsamer Tastendruck
                           CALL C, load_s0_with_01
                           CALL Z, load_s0_with_01                ; wenn 0, auf 1 setzen
                           STORE s0, s_last_key_velocity          ; neuer Raw-Wert Dynamik
                           CALL local_wr_dyntimer_s0              ; Timer mit s0 neu setzen
                           CALL local_wr_early_s3                 ; aktuellen Zustand für Early Key in RAM speichern
                           ;
                           COMPARE s3_key_status, c_key_dirty     ; nur 2. Kontakt?
                           JUMP Z, local_stop_0                   ; 2. Kontakt erreicht, 1. evt. fehlerhaft
                           COMPARE s3_key_status, c_key_on
                           JUMP Z, local_stop_0                   ; 1. und 2. Kontakt erreicht: neuer State, MIDI senden
                           COMPARE s3_key_status, c_key_idle
                           JUMP Z, local_reverse_0                ; Taste hat alle Kontakte verlassen, wieder auf Rückweg
          local_forward_0:
                           COMPARE s2, c_state_forward
                           RETURN Z                               ; State nicht neu setzen, wenn bereits Counting
                           LOAD s2, c_state_forward               ; wenn noch nicht gestartet, neuer Timer-State
                           JUMP local_wr_state_s2                 ; neuer Timer-State: c_state_forward
                           ;
                           ; ------------------------------ State "Stopped" -------------------------------
                           ;
            local_stopped: ; 2. Kontakt erreicht
                           COMPARE s3_key_status, c_key_idle
                           JUMP Z, local_reverse_0                ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                           COMPARE s3_key_status, c_key_moving
                           JUMP Z, local_reverse_0                ; Taste hat zweiten Kontakt verlassen, bewegt sich zurück
             local_stop_0:
                           COMPARE s2, c_state_stopped            ; bereits gestoppt und gesendet?
                           RETURN Z                               ; nichts machen, wenn bereits gestoppt
                           LOAD s2, c_state_stopped
                           CALL local_wr_state_s2                 ; neuer Timer-State: c_state_stopped
                           JUMP local_states_on                   ; Dynamik-Wert eintragen, MIDI ON senden und Ende
                           ;
                           ; ------------------------------ State "Reverse" -------------------------------
                           ;
            local_reverse:
                           COMPARE s3_key_status, c_key_idle
                           JUMP Z, local_idle_off                 ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                           COMPARE s3_key_status, c_key_on
                           JUMP Z, local_retrig                   ; Taste hat Endkontakt nochmal erreicht
                           COMPARE s3_key_status, c_key_dirty
                           JUMP Z, local_retrig                   ; Taste hat Endkontakt nochmal erreicht
          local_reverse_0: ; erstmals auf dem Rückweg
                           COMPARE s2, c_state_reverse            ; bereits c_state_reverse?
                           RETURN Z                               ; dann zurück
                           LOAD s2, c_state_reverse
                           CALL local_wr_state_s2                 ; neuer Timer-State: c_state_reverse
                           JUMP local_states_off                  ; Taste hat alle Kontakte verlassen, wieder in Ruhestellung
                           ;
             local_retrig: ; Retrigger mit etwas verringertem Dynamik-Wert wenn erneut ON
                           LOAD s2, c_state_stopped               ; nächster Timer-State: Stopped
                           CALL local_wr_state_s2
                           CALL local_rd_dyntimer_s0
                           LOAD s1, A0                            ; zweiter Anschlag etwas geringer
                           CALL mult_soft_s0_s1                   ; s0 x s1 => s8_msb, s7_lsb, s0 bleibt bestehen
                           COMPARE s8_msb, 00
                           CALL Z, load_s8_with_01                ; wenn 0, auf 1, Subtrahend nicht 0 werden lassen
                           STORE s8_msb, s_last_key_velocity      ; neuer Raw-Wert Dynamik
                           JUMP local_states_on                   ; Dynamik-Wert holen, MIDI ON senden und Ende
                           ;
                           ; ------------------------------------------------------------------------------
                           ; Lokale Dyntimer und States lesen/schreiben
                           ; ------------------------------------------------------------------------------
                           ;
     local_wr_dyntimer_s0: ;  Taste in RAM_ADDR, zu schreibende Daten in s0
                           LOAD s6_idx_ptr, c_page_dyntimer
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           OUTPUT s5_scan_key, RAM_ADDR           ; Tastennummer
                           OUTPUT s0, RAM_WRDATA                  ; zu schreibende Daten
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_strobe_mask
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           RETURN
                           ;
     local_rd_dyntimer_s0: ; Taste in s5_scan_key, gelesene Daten später in s0
                           LOAD s6_idx_ptr, c_page_dyntimer
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           OUTPUT s5_scan_key, RAM_ADDR           ; Tastennummer
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_read_mask
                           INPUT s0, (s6_idx_ptr)                 ; Upper, Lower oder Pedal Read
                           RETURN                                 ; Zustand in s0
                           ;
        local_wr_state_s2: ; zu schreibende Daten in s2, Taste in RAM_ADDR
                           LOAD s6_idx_ptr, c_page_keystate
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           OUTPUT s5_scan_key, RAM_ADDR           ; Tastennummer
                           OUTPUT s2, RAM_WRDATA                  ; zu schreibende Daten
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_strobe_mask
                           OUTPUT s2, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           RETURN
                           ;
        local_rd_state_s2: ; Taste in s5_scan_key, gelesene Daten später in s2
                           LOAD s6_idx_ptr, c_page_keystate
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           OUTPUT s5_scan_key, RAM_ADDR           ; Tastennummer
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_read_mask
                           INPUT s2, (s6_idx_ptr)                 ; Timer-State dieser Taste in s2
                           RETURN
                           ;
        local_wr_early_s3: ; s3_key_status auf Adresse s_local_key speichern
                           LOAD s6_idx_ptr, c_page_earlystep
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           FETCH s0, s_local_key                  ; Taste
                           OUTPUT s0, RAM_ADDR                    ; Tastennummer
                           ; gleich hier in local_steps umrechnen
                           LOAD s1, s3_key_status
                           COMPARE s1, 00
                           JUMP Z, local_wr_early_s3_0            ; wenn OFF, weiter mit 0
                           FETCH s0, s_last_key_velocity          ; letzte gemessene Dynamik
                           COMPARE s0, 00
                           CALL NZ, event_dyn2s0                  ; in 2 Stufen umrechnen
                           LOAD s1, s0
      local_wr_early_s3_0:
                           OUTPUT s1, RAM_WRDATA                  ; zu schreibende Zustand in s3_key_status
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_strobe_mask
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           RETURN
                           ;
          local_wr_dynkey:
                           ; Scanned-RAM Dynamik
                           ; Taste in s5_scan_key, s_local_dyn und s9_manual_select
                           LOAD s6_idx_ptr, c_page_velocity
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           FETCH s0, s_local_key                  ; Taste
                           OUTPUT s0, RAM_ADDR                    ; Tastennummer
                           ; Dynamik schreiben
                           FETCH s0, s_local_dyn                  ; Dynamik dieser Taste
                           OUTPUT s0, RAM_WRDATA                  ; zu schreibende Dynamik in s0
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_strobe_mask
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           ; Umgerechnet in 2 Stufen für Event-Loop
                           LOAD s6_idx_ptr, c_page_latestep
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           FETCH s0, s_local_dyn                  ; Dynamik dieser Taste
                           COMPARE s0, 00
                           CALL NZ, event_dyn2s0
                           OUTPUT s0, RAM_WRDATA                  ; zu schreibende Dynamik in s0
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_strobe_mask
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           RETURN
                           ;
                           ; ------------------------------------------------------------------------------
                           ;
          local_states_on:
                           ; Dynamik-Kurve durch variables Timer-Dekrement, simuliert 1/t
                           ; Liefert Maximalwerte, die kleiner als 255 sein können
                           ; Hier wird MIDI-Wert deshalb auf etwas über /2 korrigiert
                           ;
                           COMPARE s9_manual_select, 02
                           JUMP Z, local_states_on_pedal
                           FETCH s1, s_velocityfac                ; 0..31, von SPI_CONFIG_1 Bits 7..2
                           ; Wert bei höheren Velocity-Faktoren leicht erhöhen
                           ADD s1, 83                             ; 80 = halbierter Wert in s8_msb
                           FETCH s0, s_last_key_velocity          ; Raw-Dynamik holen
                           CALL mult_soft_s0_s1                   ; s0 x s1 => s8_msb, s7_lsb
                           LOAD s0, s8_msb
                           ADD s0, 08
                           COMPARE s0, c_midi_mindyn              ; Carry bei A - B < 0, MIDI-Minimalwert
                           CALL C, load_s0_with_mindyn            ; auf MIDI-Minimalwert setzen
                           COMPARE s0, 7F                         ; Carry bei A - B < 0
                           CALL NC, load_s0_with_7F               ; auf MIDI-Maximalwert setzen
                           STORE s0, s_last_key_velocity          ; endgültige ON-Dynamik
                           STORE s0, s_local_dyn
                           JUMP local_states_out
                           ;
    local_states_on_pedal:
                           LOAD s0, 41                            ; Pedal hat keine Dynamik, nur 1 Bit (0) im RAM
                           STORE s0, s_local_dyn
                           JUMP local_states_out
                           ;
                           ; ------------------------------------------------------------------------------
                           ;
         local_states_off:
                           LOAD s0, 00
                           STORE s0, s_local_dyn
                           ;
                           ; ------------------------------------------------------------------------------
                           ; MIDI SEND und Abschaltung über SPI $0E/2E (#14 in Firmware)
                           ; ------------------------------------------------------------------------------
                           ;
         local_states_out: ; s_local_key und s_local_dyn senden
                           ; Dynamik in s_local_dyn, Taste in s_local_key, für aktuelles Manual schreiben
                           CALL local_wr_dynkey
                           ; Parameter SPI #14 = LOCAL MIDI SEND auswerten, Bit 0 = Cancel MIDI Kanal UPPER, 1 = LOWER, 2 = PEDAL
                           INPUT s0, SPI_MIDISEND_DISABLES
                           TEST s0, 07                            ; alle Disable-Bits 0 bis 2
                           JUMP Z, local_states_send              ; gar kein Disable gesetzt wenn 0, also senden
                           ;
                           TEST s0, 01                            ; Bit 0 = UPPER
                           JUMP Z, local_states_out_1             ; kein Disable wenn 0
                           COMPARE s9_manual_select, 00
                           RETURN Z
       local_states_out_1:
                           TEST s0, 02                            ; Bit 1 = LOWER
                           JUMP Z, local_states_out_2             ; kein Disable wenn 0
                           COMPARE s9_manual_select, 01
                           RETURN Z
       local_states_out_2:
                           TEST s0, 04                            ; Bit 2 = PEDAL
                           JUMP Z, local_states_send              ; kein Disable wenn 0
                           COMPARE s9_manual_select, 02
                           RETURN Z
        local_states_send:
                           ; Manual in s9_manual_select, On/Off-Dynamik in s_local_dyn
                           ; immer auch an SAM5504 dh. MIDI_TX_SAM senden
                           FETCH s0, s_midich                     ; eingestellter Kanal
                           ADD s0, s9_manual_select               ; Manual-Nummer addieren
                           OR s0, 90
                           CALL midi_tx_s0
                           ;
                           FETCH s0, s_local_key
                           ADD s0, c_midi_offset                  ; transp. Key in s0
                           INPUT s1, SPI_KEYTRANSPOSE             ; MIDI-OUT-Transpose
                           ADD s0, s1
                           CALL midi_tx_s0
                           ;
                           FETCH s0, s_local_dyn                  ; gemessene Dynamik
                           JUMP midi_tx_s0                        ; 0 = OFF senden
                           ;
                           ; ------------------------------------------------------------------------------
                           ; Multiplier 8x8 unsigned, s0 x s1, Ergebnis in msb und lsb, s0 wird nicht verändert
                           ; ------------------------------------------------------------------------------
                           ;
           square_soft_s0: ; s0 squared => s8_msb, s7_lsb
                           LOAD s1, s0
          mult_soft_s0_s1: ; s0 x s1 => s8_msb, s7_lsb
                           LOAD s8_msb, 00
                           LOAD s6_idx_ptr, 08                    ; Schleifenzähler
                mult_loop:
                           SR0 s1
                           CALL C, mult_shift_add_s8
                           SRA s8_msb
                           SRA s7_lsb
                           SUB s6_idx_ptr, 01
                           JUMP NZ, mult_loop
                           RETURN
                           ;
        mult_shift_add_s8:
                           ADD s8_msb, s0
                           RETURN
                           ;
                           ; ------------------------------------------------------------------------------
                           ;
          load_s0_with_FF:
                           LOAD&RETURN s0, FF
                           ;
          load_s0_with_7F:
                           LOAD&RETURN s0, 7F
                           ;
          load_s0_with_01:
                           LOAD&RETURN s0, 01
                           ;
      load_s0_with_mindyn:
                           LOAD&RETURN s0, c_midi_mindyn
                           ;
          load_s8_with_01:
                           LOAD&RETURN s8_msb, 01                 ; s8_msb = 1
                           ;
                           ; ###############################################################################
                           ;
                           ;  ####### #     # ####### #     # #######  #####
                           ;  #       #     # #       ##    #    #    #     #
                           ;  #       #     # #       # #   #    #    #
                           ;  #####   #     # #####   #  #  #    #     #####
                           ;  #        #   #  #       #   # #    #          #
                           ;  #         # #   #       #    ##    #    #     #
                           ;  #######    #    ####### #     #    #     #####
                           ;
                           ; ###############################################################################
                           ;
                           ; Variablen unabhängig von Scan-Routine benutzt
                           ; s5_scan_key: Adresse des MPX-RAMs 64 Worte
                           ; ca. 165 µs Gesamtzeit bei 25-Tasten-Pedal
                           ;
           event_handling:
                           LOAD s0, 00                            ; Start mit Taste 0
                           STORE s0, s_keycount_upper
                           STORE s0, s_keycount_lower
                           STORE s0, s_pedal_on                   ; Speicher für gedrückte Taste
                           LOAD s5_scan_key, 00                   ; Start mit Taste 12
                           STORE s5_scan_key, s_scan_key_save
                           INPUT s0, SPI_CONFIG_1                 ; Early-Action-Mode?
                           TEST s0, 01                            ; AND -> Z-Flag
                           JUMP NZ, event_loop_early              ; Wenn Early Action ON
               event_loop:
                           FETCH s5_scan_key, s_scan_key_save
                           CALL event_setcontacts
                           ADD s5_scan_key, 01                    ; nächste Taste
                           STORE s5_scan_key, s_scan_key_save
                           COMPARE s5_scan_key, c_maxkeys_plus1   ; alle Tasten abgefragt?
                           JUMP NZ, event_loop
                           JUMP event_loop_exit
                           ;
         event_loop_early:
                           FETCH s5_scan_key, s_scan_key_save
                           CALL event_setcontacts_early
                           ADD s5_scan_key, 01                    ; nächste Taste
                           STORE s5_scan_key, s_scan_key_save
                           COMPARE s5_scan_key, c_maxkeys_plus1   ; alle Tasten abgefragt?
                           JUMP NZ, event_loop_early
                           ;
          event_loop_exit:
                           LOAD s0, 01
                           OUTPUT s0, PED_ACC_ENA                 ; normal ON
                           FETCH s0, s_pedal_on
                           OUTPUT s0, PEDAL_DOWN                  ; ist '1' wenn irgendeine Pedaltaste gedrückt ist
                           ;
                           ; ------------------------------------------------------------------------------
                           ; Pedal-Click, simpel, monophon
                           ; ------------------------------------------------------------------------------
                           ;
                           COMPARE s0, 00
                           JUMP Z, event_reset_pedalnoise         ; wenn kein Pedal gedrückt
                           ;
                           INPUT s1, SPI_CLICKLEN
                           AND s1, 0F
                           COMPARE s1, 00
                           JUMP Z, event_loop_nopedalclick
                           SL0 s1                                 ; verdoppeln wg. schnellerer Main Loop
                           ADD s1, 04
  event_loop_nopedalclick:
                           FETCH s0, s_pedal_noisecounter
                           COMPARE s0, s1
                           JUMP Z, event_pedal_noiseoff
                           ADD s0, 01
                           STORE s0, s_pedal_noisecounter
                           INPUT s0, RND_NUMBER
                           AND s0, 01
                           OUTPUT s0, PED_ACC_ENA                 ; Random Noise ausgeben
                           RETURN
                           ;
   event_reset_pedalnoise:
                           LOAD s0, 00
                           STORE s0, s_pedal_noisecounter
     event_pedal_noiseoff:
                           LOAD s0, 01
                           OUTPUT s0, PED_ACC_ENA                 ; normal ON
                           RETURN
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
             event_dyn2s0:
                           COMPARE s0, c_dyn_threshold            ; Dynamikschwelle
                           JUMP C, event_dyn2s0_0                 ; JUMP wenn kleiner
                           LOAD&RETURN s0, 03                     ; ist schnell
                           ;
           event_dyn2s0_0:
                           LOAD&RETURN s0, 01
                           ;
       event_dyn2s0_pedal:
                           LOAD&RETURN s0, 03                     ; ist ON
                           ;
                           ; ------------------------------------------------------------------------------
                           ;
        event_rd_step_all:
                           ; bereits von Scanned-RAM Dynamik umgerechnete 3 Bytes auf Adresse RAM_ADDR lesen
                           LOAD s6_idx_ptr, c_page_latestep
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           LOAD s0, s0                            ; Delay!
                           INPUT s0, RD_PEDAL
                           STORE s0, s_keystatus_pedal            ; 0 oder 1
                           INPUT s0, RD_LOWER
                           STORE s0, s_keystatus_lower
                           INPUT s3_key_status, RD_UPPER          ; wird ohnehin gleich gebraucht
                           RETURN
                           ;
       event_rd_early_all:
                           ; 3 Bytes s_keystatus_xxx auf Adresse RAM_ADDR lesen
                           LOAD s6_idx_ptr, c_page_earlystep
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           LOAD s0, s0                            ; Delay!
                           INPUT s0, RD_PEDAL
                           STORE s0, s_keystatus_pedal
                           INPUT s0, RD_LOWER
                           STORE s0, s_keystatus_lower
                           INPUT s3_key_status, RD_UPPER          ; wird ohnehin gleich gebraucht
                           RETURN
                           ;
       event_rd_vcont_all:
                           ; 3 Bytes s_vcont_xxx auf Adresse RAM_ADDR lesen
                           LOAD s6_idx_ptr, c_page_vcontacts
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           LOAD s0, s0                            ; Delay!
                           ;INPUT s0, RD_PEDAL
                           ;STORE s0, s_vcont_pedal                ; nicht benötigt
                           INPUT s0, RD_LOWER
                           STORE s0, s_vcont_lower
                           INPUT s4_contacts, RD_UPPER            ; wird ohnehin gleich gebraucht
                           RETURN
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; +++++++++++ Wird mit allen s5_scan_key-Tastennummern aufgerufen ++++++++++++++++
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
        event_setcontacts:
                           OUTPUT s5_scan_key, RAM_ADDR           ; Tastennummer, hier überall gültig
                           CALL event_rd_vcont_all                ; alte VCONTACT-Zustände in s_vcont_xxx, 3 Bytes
                           CALL event_rd_step_all                 ; ermittelten Step (Dynamik) aus Adresse s5_scan_key holen
                           ; Umgerechneter Tastenzustand jetzt in s_keystatus_upper, s_keystatus_lower, s_keystatus_pedal
                           JUMP event_setcontacts_0
                           ;
  event_setcontacts_early:
                           OUTPUT s5_scan_key, RAM_ADDR           ; Tastennummer, hier überall gültig
                           CALL event_rd_vcont_all                ; alte VCONTACT-Zustände in s_vcont_xxx, 3 Bytes
                           CALL event_rd_early_all                ; Early-Tastenzustand aus Adresse s5_scan_key holen
      event_setcontacts_0:
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; UPPER
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                           LOAD s9_manual_select, 00              ; 0 = UPPER
                           LOAD s0, s4_contacts
                           OR s0, s3_key_status
                           CALL NZ, mpx_setkey                    ; nur wenn nicht beide 0 sind
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; LOWER
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                           FETCH s3_key_status, s_keystatus_lower
                           FETCH s4_contacts, s_vcont_lower
                           LOAD s9_manual_select, 01              ; 1 = LOWER
                           LOAD s0, s4_contacts
                           OR s0, s3_key_status
                           CALL NZ, mpx_setkey                    ; nur wenn nicht beide 0 sind
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; PEDAL
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                           COMPARE s5_scan_key, c_maxbasskeys
                           RETURN NC                              ; wenn s5_scan_key > c_maxbasskeys
                           FETCH s3_key_status, s_keystatus_pedal
                           LOAD s9_manual_select, 02              ; 2 = PEDAL
                           JUMP mpx_setkey_pedal                  ; und zurück
                           ;
                           ;
                           ; ###############################################################################
                           ;
                           ;      #     # ######  #     #
                           ;      ##   ## #     #  #   #
                           ;      # # # # #     #   # #
                           ;      #  #  # ######     #
                           ;      #     # #         # #
                           ;      #     # #        #   #
                           ;      #     # #       #     #
                           ;
                           ; ###############################################################################
                           ; für alle Manuale, muss wg. Noise-Timer-Update ständig aufgerufen werden
                           ; ##############################################################################
                           ;
               mpx_setkey:
                           ; Offsets und Split auswerten, virtuelle Tastenkontakte setzen
                           ; scan_addr ist jetzt innerhalb Generator-Bereich 0..60
                           ; Letzten Kontakt-Zustand holen und merken. Wir verwenden diesen Wert
                           ; auch gleich zum Ermitteln der tatsächlich eingeschalteten Tasten.
                           ;
                           COMPARE s4_contacts, 00                ; alter Zustand vom letzen Durchlauf
                           JUMP Z, mpx_onoff
                           ; s_keycount_* bei tatsächlich klingenden Noten erhöhen
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, s_keycount_upper       ; Basisadresse
                           FETCH s0, (s6_idx_ptr)
                           ADD s0, 01
                           STORE s0, (s6_idx_ptr)
                           ; scan_addr für Split merken, Taste is ON
                           FETCH s0, s_scan_key_save
                           STORE s0, s_lastkey_on
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; Zugriff auf die virtuellen Tastenkontakte
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                mpx_onoff:
                           ; Sostenuto-Flag setzen, wenn SOSTENUTO aktiv und KEY ON
                           COMPARE s3_key_status, 00
                           JUMP Z, mpx_off                        ; wenn aktueller Zustand OFF
                           COMPARE s4_contacts, 0F
                           RETURN Z                               ; ist bereits ganz an, nichts machen
                           ; Tastenkontaktzustand hat sich auf ON geändert
                           ; Flag setzen, wenn Sostenuto-Pedal NICHT aktiv ist und Taste gedrückt wird.
                           ; Die dann gedrückten Tasten werden beim Ausschalten übersprungen, d.h. bleiben an
                           LOAD s6_idx_ptr, s9_manual_select      ; Sostenuto-Pedal für dieses Manual?
                           ADD s6_idx_ptr, s_sosten_upr
                           FETCH s0, (s6_idx_ptr)
                           XOR s0, FF                             ; invertieren
                           AND s0, s3_key_status
                           ; s0 ist EIN, wenn Taste EIN und Sostenuto AUS
                           CALL ramwrite_sostenutoflag_61
                           ;
                           COMPARE s3_key_status, 01
                           JUMP Z, mpx_slow                       ; nur 1. Kontakt, slow inc
                           JUMP mpx_fast                          ; 1. und/oder 2. Kontakt
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                  mpx_off:
                           COMPARE s4_contacts, 00                ; vorheriger Zustand
                           RETURN Z                               ; ist bereits ganz aus, nichts machen
                           ; Tastenkontaktzustand hat sich auf OFF geändert
                           LOAD s6_idx_ptr, s9_manual_select      ; Sostenuto-Pedal für dieses Manual?
                           ADD s6_idx_ptr, s_sosten_upr
                           FETCH s0, (s6_idx_ptr)
                           COMPARE s0, 00
                           JUMP Z, mpx_off_0                      ; Sostenuto ist aus
                           CALL ramread_sostenutoflag_61
                           COMPARE s0, 00
                           ; die bei Sostenuto NICHT gedrückten Tasten beim Ausschalten überspringen
                           RETURN NZ
                mpx_off_0:
                           LOAD s6_idx_ptr, s9_manual_select      ; Sustain-Pedal für dieses Manual?
                           ADD s6_idx_ptr, s_sustain_upr
                           FETCH s0, (s6_idx_ptr)
                           COMPARE s0, 00
                           RETURN NZ                              ; nicht abschalten, Sustain ist aktiv
                           CALL reset_noisetimer
                           LOAD s0, s4_contacts                   ; vorheriger Zustand
                           AND s0, 0F                             ; Noise wegmaskieren
                           LOAD s1, s0                            ; Steady wird jetzt Noise
                           SL0 s1                                 ; altes Steady-Nibble in oberes Noise-Nibble verschieben
                           SL0 s1
                           SL0 s1
                           SL0 s1
                           AND s1, 70                             ; Noise ohne MSBit (RFU)
                           SR0 s0                                 ; Steady-Zustand halbieren, immer halber Pegel
                           INPUT s2, SPI_CLICKLEN
                           AND s2, 0F
                           COMPARE s2, 05                         ; A < B -> C set, A >= B -> C cleared
                           CALL C, mpx_clear_s1                   ; ist kleiner als 5, dann Noise sofort löschen
                           ; Steady- (s0) und Noise-Anteil (s1) in mpx-RAM schreiben
                           ; Tastennnummer in s5_scan_key
                           ; in s9_manual_select ist aktuell abgefragtes Manual
                           OR s0, s1
                           JUMP ramwrite_vcont_61
                           ;
             mpx_clear_s1:
                           LOAD&RETURN s1, 00                     ; KeyOff-Noise löschen wenn ClickLen < 8
                           ;
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; Differenzierter Key ON-Click
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                           ; Verhalten Tastenkontakt-Bits nach Dekodierung ABC -> Kontakte aus obiger Tabelle
                           ; noise_bb_bit  steady_bb_bit  level_full_bit  Resultat
                           ; 0             0              0               OFF
                           ; 1             0              0               HALF NOISE
                           ; 0             1              0               HALF STEADY
                           ; 1             1              0               HALF NOISE, HALF STEADY
                           ; 0             0              1               OFF
                           ; 1             0              1               FULL NOISE
                           ; 0             1              1               FULL STEADY
                           ; 1             1              1               FULL STEADY
                           ;
                 mpx_fast:
                           ; Schneller Tastenanschlag, zweiter Kontakt geschlossen, voll gedrückt
                           INPUT s0, SPI_CONFIG_1                 ; Lubed Contacts?
                           TEST s0, 02                            ; AND -> Z-Flag (Bit 1 gesetzt?)
                           JUMP NZ, mpx_fast_lubed                ; Wenn Lubed Contacts Bit ON
                           ;
             mpx_fast_dry:
                           ; Dry Contact, harter Klick: Erst halfnoise, dann fullnoise, dann halfnoise_halfon, dann ON
                           CALL start_noisetimer_fastkey          ; ggf. starten, falls noch in Ruhe; aktueller noisetimer in s0
                           COMPARE s0, FF                         ; Klick beendet, d.h. Timer abgelaufen?
                           JUMP Z, mpx_fullon
                           FETCH s2, s_clicklen
                           SR1 s2                                 ; neg. Wert halbieren = Half-Click-Länge in s2
                           ;SR1 s2                                 ; neg. Wert nochmals halbieren = Quarter-Click-Länge in s2
                           COMPARE s0, s2                         ; Timer-Wert noch in s0, Quarter-Click-Länge in s2
                           JUMP NC, mpx_halfnoise_halfon          ; JUMP wenn Timer-Wert in s0 > s2, Klick kurz vor Ende?
                           ;FETCH s2, s_clicklen
                           ;SR1 s2                                  ; neg. Wert halbieren = halbe Click-Länge jetzt in s2
                           ;COMPARE s0, s2                          ; Timer-Wert noch in s0, Half-Click-Länge in s2
                           ;JUMP NC, mpx_fullnoise                  ; JUMP wenn Timer-Wert in s0 > s2, Klick halb beendet?
                           ;JUMP mpx_halfnoise
                           JUMP mpx_fullnoise
                           ;
           mpx_fast_lubed:
                           ; Lubed Contact, weicherer Klick, wie mpx_slow, aber längere Zeit
                           CALL start_noisetimer_fastkey          ; ggf. starten, falls noch in Ruhe; aktueller noisetimer in s0
                           JUMP mpx_checkhalf
                           ;
                 mpx_slow:
                           ; Langsamer Tastenanschlag oder nur erster Kontakt geschlossen
                           CALL start_noisetimer_slowkey          ; ggf. starten, falls noch in Ruhe; aktueller noisetimer in s0
            mpx_checkhalf:
                           COMPARE s0, FF                         ; Klick beendet, d.h. Timer abgelaufen?
                           JUMP Z, mpx_fullon
                           ; Wenn Hälfte der Klick-Länge erreicht, auf halfnoise_halfon umschalten
                           FETCH s2, s_clicklen
                           SR1 s2                                 ; neg. Wert halbieren = halbe Click-Länge jetzt in s2
                           COMPARE s0, s2                         ; Timer-Wert in s0, Half-Click-Länge in s2
                           JUMP NC, mpx_halfnoise_halfon          ; JUMP wenn Timer-Wert in s0 > s2, Klick halb beendet?
                           ; JUMP mpx_halfnoise
            mpx_halfnoise:
                           LOAD s0, 70                            ; half level, steady_bb_bits OFF, all noise, noise_bb_bits ON
                           JUMP ramwrite_vcont_61
            mpx_fullnoise:
                           LOAD s0, 78                            ; full level, steady_bb_bits OFF, all noise, noise_bb_bits ON
                           JUMP ramwrite_vcont_61
               mpx_halfon:
                           LOAD s0, 07                            ; half level, steady_bb_bits ON
                           JUMP ramwrite_vcont_61
     mpx_halfnoise_halfon:
                           LOAD s0, 77                            ; half level, steady_bb_bits ON, half noise, noise_bb_bits ON
                           JUMP ramwrite_vcont_61
               mpx_fullon:
                           LOAD s0, 0F                            ; full level, steady_bb_bits ON,  no noise, noise_bb_bits OFF
                           JUMP ramwrite_vcont_61
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
         mpx_setkey_pedal:
                           ; kleine Sonderbehandlung für Pedal, hat keine Dynamik und keine Noise-Bits:
                           ; s3_key_status enthält 0 (Taste aus) oder anderen Wert (Taste an),
                           ; Falls sich neue Taste geändert hat, alte Taste löschen
                           ; Vorher gespielte Pedaltaste löschen, Nummer der neue Pedaltaste merken
                           ; s9_manual_select enthält 2
                           ;
                           COMPARE s3_key_status, 00
                           JUMP Z, mpx_setkey_pedal_0             ; Taste ist aus wenn 0
                           LOAD s3_key_status, 01                 ; nur zwei Zustände zulassen, hier ON
                           FETCH s0, s_pedal_on                   ; Speicher für gedrückte Taste
                           OR s0, s3_key_status
                           STORE s0, s_pedal_on                   ; kann innerhalb Pedalschleife '1' werden
       mpx_setkey_pedal_0:
                           ; get_state/set_state hier nicht benötigt, weil kein Noise berücksichtigt wird
                           LOAD s0, s3_key_status
                           JUMP ramwrite_vcont_61                 ; Taste in s5_scan_key, Zustand in s0
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ; Werte in MPX/Scratch-RAM setzen mit aktuellem s9_manual_select und s5_scan_key
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
 ramread_sostenutoflag_61:
                           ; Sostenuto-Flag
                           ; Taste in s5_scan_key, gelesene Daten später in s0
                           LOAD s6_idx_ptr, c_page_sostenuto
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           OUTPUT s5_scan_key, RAM_ADDR           ; Tastennummer in s0
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_read_mask
                           INPUT s0, (s6_idx_ptr)                 ; Upper, Lower oder Pedal Read
                           RETURN                                 ; Zustand in s0
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
ramwrite_sostenutoflag_61:
                           ; zu schreibende Daten in s0
                           LOAD s6_idx_ptr, c_page_sostenuto
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           JUMP ramwrite_61
        ramwrite_vcont_61:
                           ; zu schreibende Daten in s0
                           LOAD s6_idx_ptr, c_page_vcontacts
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
              ramwrite_61:
                           ; zu schreibende Daten in s0, MPX-RAM Page muss gesetzt sein, 0..61
                           OUTPUT s0, RAM_WRDATA
                           OUTPUT s5_scan_key, RAM_ADDR
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_strobe_mask
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           RETURN
                           ;
                           ; ##############################################################################
                           ;
                           ;      ####### ### #     # ####### ######
                           ;         #     #  ##   ## #       #     #
                           ;         #     #  # # # # #       #     #
                           ;         #     #  #  #  # #####   ######
                           ;         #     #  #     # #       #   #
                           ;         #     #  #     # #       #    #
                           ;         #    ### #     # ####### #     #
                           ;
                           ; ##############################################################################
                           ; Hilfsroutinen: Werte in Timer/Scratch-RAM lesen oder schreiben
                           ; s9_manual_select = 0 für Upper, s9_manual_select = 1 für Lower Manual
                           ; ##############################################################################
                           ;
 start_noisetimer_fastkey:
                           ; Noise-Timer der aktuellen Taste starten, sofern nicht bereits geschehen
                           CALL get_noisetimer
                           COMPARE s0, 00
                           RETURN NZ                              ; wenn bereits gestartet
                           ;
                           INPUT s1, RND_NUMBER                   ; zufällige Länge
                           AND s1, 03                             ; 0 bis 3
                           FETCH s0, s_clicklen                   ; Timer-Startwert,  237..252
                           SUB s0, s1                             ; um Zufallswert verlängern
                           JUMP set_noisetimer
                           ;
 start_noisetimer_slowkey:
                           ; Noise-Timer der aktuellen Taste starten, sofern nicht bereits geschehen
                           CALL get_noisetimer
                           COMPARE s0, 00
                           RETURN NZ                              ; wenn bereits gestartet
                           ;
                           INPUT s1, RND_NUMBER                   ; zufällige Länge
                           AND s1, 01                             ; 0 oder 1
                           FETCH s0, s_clicklen                   ; Timer-Startwert,  237..255
                           SR1 s0                                 ; Timer-Startwert verdoppelt,  246..255
                           SUB s0, s1                             ; um kleinen Zufallswert verlängern
                           SUB s0, 01                             ; um kleinen Festwert verlängern
           set_noisetimer:
                           LOAD s6_idx_ptr, c_page_noisetimer
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           JUMP ramwrite_61
         reset_noisetimer:
                           LOAD s0, 00
                           JUMP set_noisetimer
                           ;
           get_noisetimer:
                           ; Taste in s5_scan_key, gelesene Daten später in s0
                           LOAD s6_idx_ptr, c_page_noisetimer
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           OUTPUT s5_scan_key, RAM_ADDR           ; Tastennummer in s0
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_read_mask
                           INPUT s0, (s6_idx_ptr)                 ; Upper, Lower oder Pedal Read
                           RETURN                                 ; Zustand in s0
                           ;
                           ; ##############################################################################
                           ; Dynamik- und Noise-Timer für beide Manuale aktualisieren
                           ; geändert für neues MPX-RAM ohne Autoinkrement-Timer, 20.03.2014
                           ; wird einmal pro Scan-Durchlauf aufgerufen, dauert ca. 27 µs
                           ; ##############################################################################
                           ;
       update_noisetimers:
                           FETCH s0, s_scanloop_counter
                           ADD s0, 01
                           STORE s0, s_scanloop_counter
                           TEST s0, 01                            ; AND -> Z-Flag, Bit 0, nur jeder zweite Durchlauf
                           RETURN Z
                           LOAD s6_idx_ptr, c_page_noisetimer
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page Noise-Timer
                           LOAD s5_scan_key, 00
                           ;
        update_timer_loop:
                           OUTPUT s5_scan_key, RAM_ADDR
                           ADD s5_scan_key, 01
                           INPUT s0, RD_UPPER
                           COMPARE s0, 00
                           JUMP Z, update_timer_done1             ; noch nicht gestartet
                           COMPARE s0, FF
                           JUMP Z, update_timer_done1             ; bereits abgelaufen
                           ADD s0, 01
                           OUTPUT s0, RAM_WRDATA                  ; zu schreibende Daten in s0
                           LOAD s0, 00                            ; NOP
                           OUTPUT s0, UPPER_STROBE
                           LOAD s0, 00                            ; NOP
       update_timer_done1:
                           INPUT s0, RD_LOWER
                           COMPARE s0, 00
                           JUMP Z, update_timer_done2             ; noch nicht gestartet
                           COMPARE s0, FF
                           JUMP Z, update_timer_done2             ; bereits abgelaufen
                           ADD s0, 01
                           OUTPUT s0, RAM_WRDATA                  ; zu schreibende Daten in s0
                           LOAD s0, 00                            ; NOP
                           OUTPUT s0, LOWER_STROBE
       update_timer_done2:
                           COMPARE s5_scan_key, c_maxkeys_plus1
                           JUMP NZ, update_timer_loop
                           RETURN
                           ;
                           ;
                           ; ##############################################################################
                           ;
                           ;     #     # ### ######  ###    ### #######
                           ;     ##   ##  #  #     #  #      #  #     #
                           ;     # # # #  #  #     #  #      #  #     #
                           ;     #  #  #  #  #     #  #      #  #     #
                           ;     #     #  #  #     #  #      #  #     #
                           ;     #     #  #  #     #  #      #  #     #
                           ;     #     # ### ######  ###    ### #######
                           ;
                           ; ##############################################################################
                           ;
                           ; MIDI-Subroutinen für MIDI-Empfang
                           ; Dispatcher stellt fest, ob und was es zu tun gibt
                           ; wird regelmäßig aus Hauptschleife aufgerufen
                           ;
                           ;
                           INCLUDE "midi_io.psm"
                           ;
        midi_rx_writedata:
                           ; Exit-Behandlung für midi_rx in "midi_io.psm"
                           ; Notenwert und Dynamik abspeichern
                           ; Dynamik ist 0 bei Key-Off-Befehl
                           FETCH s0, s_midi_data1                 ; MIDI-Transponierung
                           FETCH s1, s_transpose
                           ADD s0, s1
                           STORE s0, s_midi_data1
                           CALL midi_adj_foldbk                   ; Foldback, sollte evt. abschaltbar sein!
                           ;STORE s0, s_midi_data1
                           ;
                           ; Empfangsdaten, MIDI-Taste/Dynamik s_midi_data1, s_midi_data2 und s9_manual_select ins RAM 0..60
                           ;
                           LOAD s6_idx_ptr, c_page_velocity
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           FETCH s0, s_midi_data2                 ; Dynamik dieser Taste
                           OUTPUT s0, RAM_WRDATA                  ; zu schreibende Dynamik in s0
                           FETCH s0, s_midi_data1                 ; MIDI-Key in s0, geht von 12 bis 121
                           SUB s0, c_gen_firstkey
                           OUTPUT s0, RAM_ADDR
                           ; Dynamik schreiben
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_strobe_mask
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           ; Umgerechnet in 2 Stufen für Event-Loop
                           LOAD s6_idx_ptr, c_page_latestep
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           FETCH s0, s_midi_data2                 ; Dynamik dieser Taste
                           COMPARE s0, 00
                           CALL NZ, event_dyn2s0
                           LOAD s8_msb, s0
                           OUTPUT s0, RAM_WRDATA                  ; zu schreibender Step in s0
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_strobe_mask
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           ; auch für Early-Modus
                           LOAD s6_idx_ptr, c_page_earlystep
                           OUTPUT s6_idx_ptr, RAM_PAGE            ; MPX-RAM Page
                           LOAD s0, s8_msb                        ; Step dieser Taste
                           OUTPUT s0, RAM_WRDATA                  ; zu schreibender Step in s0
                           LOAD s6_idx_ptr, s9_manual_select      ; 0 oder 1
                           ADD s6_idx_ptr, c_strobe_mask
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           RETURN
                           ;
                           ; ##############################################################################
                           ;
                           ;      ### #     # ### #######
                           ;       #  ##    #  #     #
                           ;       #  # #   #  #     #
                           ;       #  #  #  #  #     #
                           ;       #  #   # #  #     #
                           ;       #  #    ##  #     #
                           ;      ### #     # ###    #
                           ;
                           ; ##############################################################################
                           ;
                scan_init:
                           INPUT s0, FEATURE_SPI_FLAG
                           SR0 s0                                 ; Bit 1 (Flag) jetzt Bit 0
                           OUTPUT s0, MIDI_USE_NEW_ROUTING
                           STORE s0, s_midi_sam_has_fifo
                           LOAD s0, 00
                           OUTPUT s0, SCANPORT
                           OUTPUT s0, STATUS
                           OUTPUT s0, MIDI_OUT_SEL
                           STORE s0, s_midi_1_rxflag              ; Rx-Flag löschen
                           STORE s0, s_midi_2_rxflag              ; Rx-Flag löschen
                           STORE s0, s_midi_avr_rxflag            ; Rx-Flag löschen
                           STORE s0, s_midi_sam_rxflag            ; Rx-Flag löschen
                           LOAD s9_manual_select, 00
                           LOAD s8_msb, 00
                           LOAD s7_lsb, 00
                           LOAD s5_scan_key, 00
                           LOAD s3_key_status, 00
                           ; INIT Message mit ScanCore Info
                           LOAD s0, c_corevers
                           OUTPUT s0, MIDI_DB2
                           LOAD s0, c_corerevi
                           OUTPUT s0, MIDI_DB1
                           LOAD s0, AA
                           OUTPUT s0, MIDI_CMD
                           CALL midi_strobe_avr
                           LOAD s0, 00
                           LOAD s6_idx_ptr, 00
        zero_scratch_loop:
                           STORE s0, (s6_idx_ptr)                 ;s0 ist noch 00
                           ADD s6_idx_ptr, 01
                           COMPARE s6_idx_ptr, 40
                           JUMP NZ, zero_scratch_loop
                           ;
                           LOAD s0, 40
                           STORE s0, s_last_key_velocity
                           LOAD s6_idx_ptr, 00
                           CALL scan_wait_init
                           LOAD s0, 00
                           OUTPUT s0, RAM_PAGE
                           JUMP send_alloff
                           ;
       allnotesoff_manual:
                           LOAD s0, 00
                           STORE s0, s_sustain_upr
                           STORE s0, s_sustain_lwr
                           STORE s0, s_sosten_upr
                           STORE s0, s_sosten_lwr
                           ; alle Tasten löschen
                           FETCH s6_idx_ptr, s_midi_chan_masked
                           FETCH s1, s_midich                     ; eingestellter Kanal
                           SUB s6_idx_ptr, s1                     ; Manual in s6_idx_ptr
                           ADD s6_idx_ptr, c_strobe_mask          ; 0 bis 2 plus Offset
                           OUTPUT s0, RAM_WRDATA                  ; zu schreibende Dynamik INPUT s0
                           LOAD s1, 00                            ; Schleifenzähler
                           ; keine set_ram-Routine, da sA_page_select, s5_scan_key etc. nicht gültig!
 allnotesoff_manual_loop1:
                           OUTPUT s1, RAM_ADDR                    ; Tastennummer in s1
                           LOAD s0, c_page_earlystep
                           OUTPUT s0, RAM_PAGE                    ; MPX-RAM Page
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           LOAD s0, c_page_velocity
                           OUTPUT s0, RAM_PAGE                    ; MPX-RAM Page
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           LOAD s0, c_page_keystate
                           OUTPUT s0, RAM_PAGE                    ; MPX-RAM Page
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           LOAD s0, c_page_keystate
                           OUTPUT s0, RAM_PAGE                    ; MPX-RAM Page
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           LOAD s0, c_page_sostenuto
                           OUTPUT s0, RAM_PAGE                    ; MPX-RAM Page
                           OUTPUT s0, (s6_idx_ptr)                ; Upper, Lower oder Pedal Strobe
                           ADD s1, 01
                           COMPARE s1, 64'd
                           JUMP NZ, allnotesoff_manual_loop1
                           RETURN
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
                page_init:
                           ; alle Töne, Flags und Timer löschen
                           LOAD s0, 00
                           STORE s0, s_sustain_upr
                           STORE s0, s_sustain_lwr
                           STORE s0, s_sosten_upr
                           STORE s0, s_sosten_lwr
                           OUTPUT s0, RAM_WRDATA                  ; Enables und Werte auf 0
                           OUTPUT s0, PEDAL_DOWN
                           LOAD s5_scan_key, 00
                           LOAD s6_idx_ptr, 00
           page_init_loop:
                           OUTPUT s5_scan_key, RAM_ADDR
                           OUTPUT s6_idx_ptr, RAM_PAGE
                           OUTPUT s0, UPPER_STROBE
                           OUTPUT s0, LOWER_STROBE
                           OUTPUT s0, PEDAL_STROBE
                           ADD s5_scan_key, 01
                           COMPARE s5_scan_key, 64'd              ; 64 Durchläufe?
                           JUMP NZ, page_init_loop
                           LOAD s5_scan_key, 00
                           ADD s6_idx_ptr, 01
                           COMPARE s6_idx_ptr, 16'd               ; 16 Durchläufe?
                           JUMP NZ, page_init_loop
                           RETURN                                 ; fertig
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
              scan_config:
                           LOAD s0, 00
                           FETCH s1, s_keycount_upper             ; Anzahl gedrückter Tasten Upper
                           COMPARE s1, 00
                           CALL NZ, load_s0_with_FF
                           OUTPUT s0, KEYS_ON_UPR
                           ;
                           LOAD s0, 00
                           FETCH s1, s_keycount_lower             ; Anzahl gedrückter Tasten Lower
                           COMPARE s1, 00
                           CALL NZ, load_s0_with_FF
                           OUTPUT s0, KEYS_ON_LWR
                           ;
                           INPUT s0, SPI_CONFIG_1
                           SR0 s0
                           SR0 s0
                           SR0 s0
                           STORE s0, s_velocityfac                ; waren Bits 7..2 (0..63), nochmals halbiert auf 0..31
                           INPUT s0, SPI_GENTRANSPOSE
                           FETCH s1, s_transpose
                           COMPARE s0, s1
                           STORE s0, s_transpose
                           CALL NZ, send_alloff                   ; Generator-Transpose geändert
                           INPUT s1, SPI_CLICKLEN
                           AND s1, 0F                             ; max. 15 ms
                           LOAD s0, FF
                           SUB s0, s1
                           STORE s0, s_clicklen                   ; Startwert 1ms-Timer, max. 255
                           INPUT s0, SPI_CLICKLEN
                           AND s0, F0
                           SR0 s0
                           SR0 s0                                 ; Wert immer noch vervierfacht
                           ; z.B. $13(5A) = Teilfaktor 4954 für 10 kHz Samples oder 5 kHz Noise-Frequenz
                           OUTPUT s0, NOISE_FREQ
                           ; MIDI-Kanal geändert?
                           FETCH s1, s_midich
                           INPUT s0, SPI_MIDICH
                           COMPARE s0, s1
                           STORE s0, s_midich
                           CALL NZ, send_alloff                   ; wenn MIDI-Kanal geändert
                           ; OUTPUT s0, AUXPORT ; Trigger für LA
                           INPUT s0, SPI_MIDIOPT
                           OUTPUT s0, MIDI_OUT_SEL
                           ;
                           ; Split überprüfen. In SPI_XXX befindet sich ggf. neue Split-ON/OFF-Einstellung vom Panel
                           FETCH s0, s_splitpoint
                           INPUT s1, SPI_SPLITPOINT
                           STORE s1, s_splitpoint
                           COMPARE s0, s1
                           CALL NZ, split_changed                 ; wenn geändert
                           ;
                           FETCH s0, s_splitmode
                           INPUT s1, SPI_SPLITMODE
                           STORE s1, s_splitmode
                           COMPARE s0, s1
                           CALL NZ, split_changed                 ; wenn geändert
                           ;
                           FETCH s0, s_split_on                   ; alter Split-On-Zustand
                           INPUT s1, SPI_SPLITON                  ; neu von Bedienelement
                           STORE s1, s_split_on
                           AND s0, 03
                           AND s1, 03
                           COMPARE s0, s1
                           RETURN Z                               ; wenn nicht geändert, Ende
                           ; weiter mit split_changed
                           ;
            split_changed:
                           CALL send_alloff
                           CALL wait_keys_released                ;´Auf Loslassen aller Tasten warten
                           ;
                           FETCH s0, s_split_on
                           AND s0, 03
                           COMPARE s0, 00
                           RETURN Z                               ; wenn wieder ausgeschaltet
                           ;
                           ; s0 als PGM senden (TEST)
                           FETCH s0, s_split_on
                           CALL midi_testout
                           ;
                           ;
                           ; ##############################################################################
                           ; Splitmode setzen:
                           ; 0 = PedalToLower,
                           ; 1 = LowerToUpper
                           ; 2 = PedalToUpper
                           ; 3 = LowerToUpper + 1 Oktave
                           ; 4 = LowerToUpper + 2 Oktaven
                           ; 5 = Add Pedal to Lower
                           ; ##############################################################################
                           ;
           set_splitpoint:
                           FETCH s0, s_split_on
                           AND s0, 03
                           ; COMPARE s0, 00                            ; nun ausgeschaltet?
                           RETURN Z                               ; dann Ende
                           ; Split-Funktion wurde seit letztem Durchlauf von OFF auf ON geändert.
                           ; Feststellen, ob Keyboard-Tasten gedrückt wurden, dann diese setzen und als
                           ; Splitpoint an AVR senden.
                           FETCH s0, s_keycount_upper
                           FETCH s1, s_keycount_lower
                           ADD s0, s1
                           COMPARE s0, 00
                           RETURN Z                               ; keine Tasten gedrückt, alter Splitmode
                           ;
                           FETCH s0, s_lastkey_on
                           STORE s0, s_splitpoint
                           ;
                           COMPARE s1, 00
                           JUMP Z, set_splitpoint_upper           ; keine Tasten auf Lower, also Upper
                           SUB s1, 01
                           COMPARE s1, 00                         ; enthält jetzt s_keycount_lower -1
                           ; wenn nur eine Taste gedrückt, SplitMode 0 = PedalToLower speichern
                           JUMP Z, set_splitpoint_to_AVR
                           ; es sind hier mehrere Tasten auf Lower gedrückt, Mode 5 = Add Pedal to Lower einstellen
                           LOAD s1, 05
                           JUMP set_splitpoint_to_AVR
                           ;
     set_splitpoint_upper:
                           ; Anzahl der Tasten Obermanual ist zufällig auch Splitmode 0..4
                           FETCH s1, s_keycount_upper
    set_splitpoint_to_AVR:
                           STORE s1, s_splitmode
                           ; gewünschten Splitmode an AVR senden, über internal MIDI an Controller $70 und $71
                           LOAD s0, B0
                           OUTPUT s0, MIDI_CMD
                           LOAD s0, 76
                           OUTPUT s0, MIDI_DB1
                           OUTPUT s1, MIDI_DB2
                           CALL midi_strobe_avr
                           ; MIDI_CMD bleibt!
                           LOAD s0, 77
                           OUTPUT s0, MIDI_DB1
                           FETCH s0, s_splitpoint
                           OUTPUT s0, MIDI_DB2
                           CALL midi_strobe_avr
                           ;
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
              send_alloff:
                           CALL page_init                         ; Lokale Noten löschen
                           FETCH s0, s_midich                     ; an alle MIDI-Kanäle senden
                           ADD s0, B0
                           CALL send_alloff_data
                           FETCH s0, s_midich
                           ADD s0, B1
                           CALL send_alloff_data
                           FETCH s0, s_midich
                           ADD s0, B2
                           ; weiter mit  send_alloff_data
         send_alloff_data:
                           CALL midi_tx_s0
                           LOAD s0, 7B                            ; Controller 123
                           CALL midi_tx_s0
                           LOAD s0, 7F                            ; 127
                           CALL midi_tx_s0
                           RETURN
                           ;
                           ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
                           ;
           scan_wait_init:
                           LOAD s0, c_scankey_delay               ; Scan-Timer neu laden
                           OUTPUT s0, SCANTIMER_VAL
                           RETURN
